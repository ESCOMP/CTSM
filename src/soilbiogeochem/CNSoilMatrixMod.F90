module CNSoilMatrixMod

!#include "shr_assert.h"
  !-----------------------------------------------------------------------
  ! The matrix model of CLM5.0 was developed by Yiqi Luo EcoLab members,
  ! Drs. Xingjie Lu, Yuanyuan Huang and Zhengguang Du, at Northern Arizona University
  !----------------------------------------------------------------------------------
  ! 
  ! DESCRIPTION:
  ! Module for CLM5.0BGC matrices
  ! The matrix equation 
  ! Xn+1 = Xn + I*dt + (A*K(ksi) - Kfire - tri/dz)*Xn*dt
  ! Or
  ! Xn+1 = Xn + I*dt + (A*K(ksi) - Kfire - V)*Xn*dt
  
  ! !USES:
  use shr_kind_mod                       , only : r8 => shr_kind_r8
  use shr_log_mod                        , only : errMsg => shr_log_errMsg
  use decompMod                          , only : bounds_type  
  use abortutils                         , only : endrun
  use clm_time_manager                   , only : get_step_size, is_end_curr_month,get_curr_date
  use clm_time_manager                   , only : is_first_step_of_this_run_segment,is_beg_curr_year,is_end_curr_year
  use clm_varpar                         , only : ndecomp_pools, nlevdecomp, ndecomp_pools_vr        !number of biogeochemically active soil layers
  use clm_varpar                         , only : ndecomp_cascade_transitions, ndecomp_cascade_outtransitions
  use clm_varpar                         , only : i_met_lit, i_cel_lit, i_lig_lit, i_cwd
  use clm_varcon                         , only : dzsoi_decomp,zsoi,secspday
  use SoilBiogeochemDecompCascadeConType , only : decomp_cascade_con    
  use CNVegCarbonFluxType                , only : cnveg_carbonflux_type
  use CNVegNitrogenFluxType              , only : cnveg_nitrogenflux_type
  use SoilBiogeochemStateType            , only : soilbiogeochem_state_type
  use SoilBiogeochemCarbonStateType      , only : soilbiogeochem_carbonstate_type
  use SoilBiogeochemCarbonFluxType       , only : soilbiogeochem_carbonflux_type
  use SoilBiogeochemNitrogenStateType    , only : soilbiogeochem_nitrogenstate_type
  use SoilBiogeochemNitrogenFluxType     , only : soilbiogeochem_nitrogenflux_type  
  use CNSharedParamsMod                  , only : CNParamsShareInst
  use SoilStateType                      , only : soilstate_type  
  use clm_varctl                         , only : isspinup, use_soil_matrixcn, is_outmatrix
  use ColumnType                         , only : col                
  use GridcellType                       , only : grc
  use clm_varctl                         , only : use_c13, use_c14
  use perf_mod                           , only : t_startf, t_stopf
  use SPMMod                             , only : sparse_matrix_type, diag_matrix_type, vector_type
!
  implicit none
  private
  !
  ! !PUBLIC MEMBER FUNCTIONS:
  public:: CNSoilMatrix
  !-----------------------------------------------------------------------

contains

  !-----------------------------------------------------------------------
  subroutine CNSoilMatrix(bounds,num_soilc, filter_soilc, num_actfirec, filter_actfirec,&
       cnveg_carbonflux_inst,soilbiogeochem_carbonstate_inst, &
       soilbiogeochem_carbonflux_inst,soilbiogeochem_state_inst, &
       cnveg_nitrogenflux_inst, soilbiogeochem_nitrogenflux_inst, &
       soilbiogeochem_nitrogenstate_inst,c13_soilbiogeochem_carbonstate_inst,&
       c13_soilbiogeochem_carbonflux_inst,c14_soilbiogeochem_carbonstate_inst,&
       c14_soilbiogeochem_carbonflux_inst)
    ! !DESCRIPTION:
    ! !ARGUMENTS:
    type(bounds_type)                        , intent(in)    :: bounds
    integer                                  , intent(in)    :: num_soilc       ! number of soil columns in filter
    integer                                  , intent(in)    :: filter_soilc(:) ! filter for soil columns
    integer                                  , intent(in)    :: num_actfirec       ! number of soil columns in filter
    integer                                  , intent(in)    :: filter_actfirec(:) ! filter for soil columns
    type(cnveg_carbonflux_type)              , intent(inout) :: cnveg_carbonflux_inst
    type(soilbiogeochem_carbonstate_type)    , intent(inout) :: soilbiogeochem_carbonstate_inst
    type(soilbiogeochem_carbonflux_type)     , intent(inout) :: soilbiogeochem_carbonflux_inst
    type(soilbiogeochem_state_type)          , intent(inout) :: soilbiogeochem_state_inst
    type(cnveg_nitrogenflux_type)            , intent(inout) :: cnveg_nitrogenflux_inst
    type(soilbiogeochem_nitrogenflux_type)   , intent(inout) :: soilbiogeochem_nitrogenflux_inst
    type(soilbiogeochem_nitrogenstate_type)  , intent(inout) :: soilbiogeochem_nitrogenstate_inst
    type(soilbiogeochem_carbonstate_type)    , intent(inout) :: c13_soilbiogeochem_carbonstate_inst
    type(soilbiogeochem_carbonflux_type)     , intent(inout) :: c13_soilbiogeochem_carbonflux_inst
    type(soilbiogeochem_carbonstate_type)    , intent(inout) :: c14_soilbiogeochem_carbonstate_inst
    type(soilbiogeochem_carbonflux_type)     , intent(inout) :: c14_soilbiogeochem_carbonflux_inst

    ! !LOCAL VARIABLES:
    integer :: fc,j,i, l,k ! indices
    integer :: c     !  
    real(r8):: dt                   ! time step (seconds)
    real(r8):: epsi,fire_delta      ! small number

    integer :: begc,endc                                    ! bounds 
    real(r8),dimension(bounds%begc:bounds%endc,nlevdecomp*(ndecomp_cascade_transitions-ndecomp_cascade_outtransitions)) :: a_ma_vr,na_ma_vr

    real(r8),dimension(bounds%begc:bounds%endc,1:ndecomp_pools_vr,1) ::  soilmatrixc_cap,soilmatrixn_cap
    real(r8), dimension(1:ndecomp_pools_vr,1:ndecomp_pools_vr)   ::  AKinv,AKinvn

    real(r8),dimension(bounds%begc:bounds%endc,1:nlevdecomp,1:ndecomp_pools) :: cn_decomp_pools
    integer :: Ntrans
    integer tranlist_a
    integer j_decomp,j_lev
    integer,dimension(:) :: kfire_i(1:ndecomp_pools_vr)
    integer,dimension(:) :: kfire_j(1:ndecomp_pools_vr)
    real(r8),dimension(:,:) :: Cinter_old(bounds%begc:bounds%endc,1:ndecomp_pools_vr)
    real(r8),dimension(:,:) :: Ninter_old(bounds%begc:bounds%endc,1:ndecomp_pools_vr)
    logical,save :: list_ready1_fire   = .False.
    logical,save :: list_ready1_nofire = .False.
    logical,save :: list_ready2_fire   = .False.
    logical,save :: list_ready2_nofire = .False.
    logical,save :: init_readyAsoilc = .False.
    logical,save :: init_readyAsoiln = .False.
    logical isbegofyear

    !-----------------------------------------------------------------------
    begc = bounds%begc; endc = bounds%endc
    
!    SHR_ASSERT_ALL((ubound(cn_decomp_pools)     == (/endc,nlevdecomp,ndecomp_pools/))  , errMsg(sourcefile, __LINE__))
    associate(                                      &
    cs_soil   => soilbiogeochem_carbonstate_inst    , & ! In/Output
    ns_soil   => soilbiogeochem_nitrogenstate_inst  , & ! In/Output
    cs13_soil => c13_soilbiogeochem_carbonstate_inst, & ! In/Output 
    cs14_soil => c14_soilbiogeochem_carbonstate_inst, & ! In/Output 

    fpi_vr                        => soilbiogeochem_state_inst%fpi_vr_col                 ,&!Input:[real(r8)(:,:)]fraction of potential immobilization (no units)
    cascade_donor_pool            => decomp_cascade_con%cascade_donor_pool                ,&!Input:[integer(:)]which pool is C taken from for a given decomposition step
    cascade_receiver_pool         => decomp_cascade_con%cascade_receiver_pool             ,&!Input:[integer(:)]which pool is C added to for a given decomposition step 
    floating_cn_ratio_decomp_pools=> decomp_cascade_con%floating_cn_ratio_decomp_pools    ,&!Input:[logical(:)]TRUE => pool has fixed C:N ratio
    initial_cn_ratio              => decomp_cascade_con%initial_cn_ratio                  ,&!Input:[real(r8)(:)]c:n ratio for initialization of pools
    rf_decomp_cascade             => soilbiogeochem_state_inst%rf_decomp_cascade_col      ,&!Input:[real(r8)(:,:,:)]respired fraction in decomposition step (frac)
    pathfrac_decomp_cascade       => soilbiogeochem_state_inst%pathfrac_decomp_cascade_col,&!Input:[real(r8)(:,:,:)]what fraction of C leaving a given pool passes 
                                                                                            !                       through a given transition (frac)
    is_cwd                        => decomp_cascade_con%is_cwd                            ,&!Input:[logical(:)]TRUE => pool is a cwd pool
    is_litter                     => decomp_cascade_con%is_litter                         ,&!Input:[logical(:)]TRUE => pool is a litter pool

    hr                         => soilbiogeochem_carbonflux_inst%hr_col                   ,&!Output:[real(r8)(:)]heterotrophic respiration
    m_decomp_cpools_to_fire    => cnveg_carbonflux_inst%m_decomp_cpools_to_fire_col       ,&!Output:[real(r8)(:,:)]vertically-integrated decomposing C fire loss
    tri_ma_vr                  => soilbiogeochem_carbonflux_inst%tri_ma_vr                ,&!Input:[real(r8)(:,:)]vertical C transfer rate (gC/(gC*m3*step))
    matrix_decomp_fire_k       => soilbiogeochem_carbonflux_inst%matrix_decomp_fire_k_col ,&!Input:[real(r8)(:,:)]decomposition rate due to fire (gC/(gC*m3*step))

    AKsoilc        => soilbiogeochem_carbonflux_inst%AKsoilc   ,&!Output:[SparseMatrix] A*K for C transfers between pools
    RI_a           => soilbiogeochem_carbonflux_inst%RI_a      ,&!In/Output:[Integer(:)] Row numbers of all entries from AKsoilc, which can be generated by SetValueA
    CI_a           => soilbiogeochem_carbonflux_inst%CI_a      ,&!In/Output:[Integer(:)] Column numbers of all entries from AKsoilc, which can be generated by SetValueA
    AKsoiln        => soilbiogeochem_nitrogenflux_inst%AKsoiln ,&!Output:[SparseMatrix] A*K for N transfers between pools
    RI_na          => soilbiogeochem_nitrogenflux_inst%RI_na   ,&!In/Output:[Integer(:)] Row numbers of all entries from AKsoiln, which can be generated by SetValueA
    CI_na          => soilbiogeochem_nitrogenflux_inst%CI_na   ,&!In/Output:[Integer(:)] Column numbers of all entries from AKsoiln, which can be generated by SetValueA

    A_i            => decomp_cascade_con%A_i                   ,&!Input:[integer(:)] Prescribed row number of all elements in a_ma_vr
    A_j            => decomp_cascade_con%A_j                   ,&!Input:[integer(:)] Prescribed column number of all elements in na_ma_vr
    spm_tranlist_a => decomp_cascade_con%spm_tranlist_a        ,&!Input:[integer(:,:)] Prescribed subscript to map transitions and soil layer to a_ma_vr and na_ma_vr

    AVsoil         => soilbiogeochem_carbonflux_inst%AVsoil    ,&!Output:[SparseMatrix] V for C and N transfers between soil layers
    tri_i          => decomp_cascade_con%tri_i                 ,&!Input:[integer(:)] Prescribed row index of all entries in AVsoil
    tri_j          => decomp_cascade_con%tri_j                 ,&!Input:[integer(:)] Prescribed column index of all entries in AVsoil
    Ntri_setup     => decomp_cascade_con%Ntri_setup            ,&!Input:[integer] Number of non-zero entries in AVsoil

    AKfiresoil     => soilbiogeochem_carbonflux_inst%AKfiresoil,&!Output:[SparseMatrix] Kfire for CN transfers from soil to atm due to fire

    AKallsoilc     => soilbiogeochem_carbonflux_inst%AKallsoilc     ,&!Output:[SparseMatrix] (A*K+V-Kfire) for soil C cycle
    NE_AKallsoilc  => soilbiogeochem_carbonflux_inst%NE_AKallsoilc  ,&!In/Output:[Integer] Number of entries in AKallsoilc, which can be generated by SPMP_*
    RI_AKallsoilc  => soilbiogeochem_carbonflux_inst%RI_AKallsoilc  ,&!In/Output:[Integer(:)] Row numbers of entries in AKallsoilc, which can be generated by SPMP_*
    CI_AKallsoilc  => soilbiogeochem_carbonflux_inst%CI_AKallsoilc  ,&!In/Output:[Integer(:)] Column numbers of entries in AKallsoilc, which can be generated by SPMP_*
    AKallsoiln     => soilbiogeochem_nitrogenflux_inst%AKallsoiln   ,&!Output:[SparseMatrix] (A*K+V-Kfire) for soil N cycle
    NE_AKallsoiln  => soilbiogeochem_nitrogenflux_inst%NE_AKallsoiln,&!In/Output:[Integer] Number of entries in AKallsoilc, which can be generated by SPMP_*
    RI_AKallsoiln  => soilbiogeochem_nitrogenflux_inst%RI_AKallsoiln,&!In/Output:[Integer(:)] Row numbers of entries in AKallsoilc, which can be generated by SPMP_*
    CI_AKallsoiln  => soilbiogeochem_nitrogenflux_inst%CI_AKallsoiln,&!In/Output:[Integer(:)] Column numbers of entries in AKallsoilc, which can be generated by SPMP_*
    AKXcacc        => soilbiogeochem_carbonstate_inst%AKXcacc       ,&!In/Output:[SparseMatrix] Accumulated transfers for soil C cycle
    AKXnacc        => soilbiogeochem_nitrogenstate_inst%AKXnacc     ,&!In/Output:[SparseMatrix] Accumulated transfers for soil N cycle
    n_all_entries  => decomp_cascade_con%n_all_entries  ,&!Input:[integer] Number of all entries in AKallsoilc, AKallsoiln, AKXcacc, and AKXnacc
    all_i          => decomp_cascade_con%all_i          ,&!Input:[integer(:)] Prescribed row index of all entries in AKallsoilc, AKallsoiln, AKXcacc, and AKXnacc
    all_j          => decomp_cascade_con%all_j          ,&!Input:[integer(:)] Prescribed column index of all entries in AKallsoilc, AKallsoiln, AKXcacc, and AKXnacc

    Ksoil          => soilbiogeochem_carbonflux_inst%Ksoil             ,&!Output:[DiagonalMatrix] CN turnover rate in different soil pools and layers
    Xdiagsoil      => soilbiogeochem_carbonflux_inst%Xdiagsoil         ,&!Output:[DiagonalMatrix] Temporary C and N state variable to calculate accumulation transfers
    matrix_Cinter  => soilbiogeochem_carbonstate_inst%matrix_Cinter    ,&!In/Output:[Vector] Soil C state variables (gC/m3) in different soil pools and layers
    matrix_Ninter  => soilbiogeochem_nitrogenstate_inst%matrix_Ninter  ,&!In/Output:[Vector] Soil N state variables (gN/m3) in different soil pools and layers
    matrix_Cinter13=> c13_soilbiogeochem_carbonstate_inst%matrix_Cinter,&!In/Output:[Vector] Soil C13 state variables (gC13/m3) in different soil pools and layers
    matrix_Cinter14=> c14_soilbiogeochem_carbonstate_inst%matrix_Cinter,&!In/Output:[Vector] Soil C14 state variables (gC14/m3) in different soil pools and layers
    matrix_Cinput  => soilbiogeochem_carbonflux_inst%matrix_Cinput     ,&!Input:[Vector] C input to different soil compartments (pools and layers) (gC/m3/step)
    matrix_Cinput13=> c13_soilbiogeochem_carbonflux_inst%matrix_Cinput ,&!Input:[Vector] C13 input to different soil compartments (pools and layers) (gC13/m3/step)
    matrix_Cinput14=> c14_soilbiogeochem_carbonflux_inst%matrix_Cinput ,&!Input:[Vector] C14 input to different soil compartments (pools and layers) (gC14/m3/step)
    matrix_Ninput  => soilbiogeochem_nitrogenflux_inst%matrix_Ninput   ,&!Input:[Vector] N input to different soil compartments (pools and layers) (gN/m3/step)

    list_Asoilc      => decomp_cascade_con%list_Asoilc      ,&!In/Output:[Integer(:)] Saves how non-diagonal entries in a_ma_vr are mapped to full matrix AKsoilc
    list_Asoiln      => decomp_cascade_con%list_Asoiln      ,&!In/Output:[Integer(:)] Saves how non-diagonal entries in na_ma_vr are mapped to full matrix AKsoiln
    list_V_AKVfire   => decomp_cascade_con%list_V_AKVfire   ,&!In/Output:[Integer(:)] Saves how entries in V are mapped to (A*K+V-Kfire) in the addition SPMP_ABC
    list_fire_AKVfire=> decomp_cascade_con%list_fire_AKVfire,&!In/Output:[Integer(:)] Saves how entries in Kfire are mapped to (A*K+V-Kfire) in the addition SPMP_ABC
    list_AK_AKVfire  => decomp_cascade_con%list_AK_AKVfire  ,&!In/Output:[Integer(:)] Saves how entries in A*K are mapped to (A*K+V-Kfire) in the addition SPMP_ABC
    list_AK_AKV      => decomp_cascade_con%list_AK_AKV      ,&!In/Output:[Integer(:)] Saves how entries in A*K are mapped to (A*K+V) in the addition SPMP_AB
    list_V_AKV       => decomp_cascade_con%list_V_AKV        &!In/Output:[Integer(:)] Saves how entries in V are mapped to (A*K+V) in the addition SPMP_AB 
    )

     ! set time steps
      call t_startf('CN Soil matrix-init. matrix')
      dt = real( get_step_size(), r8 )

      Ntrans = (ndecomp_cascade_transitions-ndecomp_cascade_outtransitions)*nlevdecomp
      epsi = 1.e-30_r8 

      isbegofyear = is_beg_curr_year()

      ! calculate c:n ratios of applicable pools
      do l = 1, ndecomp_pools
         if ( floating_cn_ratio_decomp_pools(l)) then
            do j = 1,nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  if ( ns_soil%decomp_npools_vr_col(c,j,l) > 0._r8 ) then
                     cn_decomp_pools(c,j,l) = cs_soil%decomp_cpools_vr_col(c,j,l) / ns_soil%decomp_npools_vr_col(c,j,l)
                  else
                     cn_decomp_pools(c,j,l) = initial_cn_ratio(l)
                  end if
               end do
            end do
         else
            do j = 1,nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  cn_decomp_pools(c,j,l) = initial_cn_ratio(l)
               end do
            end do
         end if 
      end do

      call t_stopf('CN Soil matrix-init. matrix')

      call t_startf('CN Soil matrix-assign matrix-a-na')
  ! Calculate non-diagonal entries (a_ma_vr and na_ma_vr) in transfer coefficient matrix A 
      do k = 1, ndecomp_cascade_transitions
         if(cascade_receiver_pool(k) .ne. 0)then  !transition to atmosphere
            do j = 1, nlevdecomp
               tranlist_a = spm_tranlist_a(j,k)
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  a_ma_vr(c,tranlist_a) = (1.0_r8-rf_decomp_cascade(c,j,k))*pathfrac_decomp_cascade(c,j,k)
                  if( .not. floating_cn_ratio_decomp_pools(cascade_receiver_pool(k)))then
                     na_ma_vr(c,tranlist_a) = (1.0_r8-rf_decomp_cascade(c,j,k))* &
                               (cn_decomp_pools(c,j,cascade_donor_pool(k))/cn_decomp_pools(c,j,cascade_receiver_pool(k)))*pathfrac_decomp_cascade(c,j,k)
                  else
                     na_ma_vr(c,tranlist_a) = pathfrac_decomp_cascade(c,j,k)
                  end if
               end do
            end do
         end if
      end do

      call t_stopf('CN Soil matrix-assign matrix-a-na')

  ! Update the turnover rate matrix K with N limitation (fpi_vr)
      call t_startf('CN Soil matrix-assign matrix-in')
      do i = 1,ndecomp_pools
         if(is_litter(i))then
            do j = 1, nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  Ksoil%DM(c,(i-1)*nlevdecomp+j)   = Ksoil%DM(c,(i-1)*nlevdecomp+j) * fpi_vr(c,j) 
               end do
            end do
         end if
      end do

      call t_stopf('CN Soil matrix-assign matrix-in')

  ! Assign old value to vector, and be ready for matrix operation
      call t_startf('CN Soil matrix-assign matrix-in')
      call t_startf('CN Soil matrix-assign matrix-inter')
      do i = 1,ndecomp_pools
         do j = 1, nlevdecomp
            do fc = 1,num_soilc
               c = filter_soilc(fc)
                  matrix_Cinter%V(c,j+(i-1)*nlevdecomp)   = cs_soil%decomp_cpools_vr_col(c,j,i)                
                  Cinter_old(c,j+(i-1)*nlevdecomp)        = cs_soil%decomp_cpools_vr_col(c,j,i) 
                  !Cinter_old is saved for accumulation of C transfer calculation and C flux (hr and fire) adjustment
                  matrix_Ninter%V(c,j+(i-1)*nlevdecomp)   = ns_soil%decomp_npools_vr_col(c,j,i)     
                  Ninter_old(c,j+(i-1)*nlevdecomp)        = ns_soil%decomp_npools_vr_col(c,j,i)
                  !Ninter_old is saved for accumulation of N transfer calculation
            end do
         end do
      end do
      if ( use_c13 )then
         do i = 1,ndecomp_pools
            do j = 1, nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                     matrix_Cinter13%V(c,j+(i-1)*nlevdecomp)   = cs13_soil%decomp_cpools_vr_col(c,j,i)
               end do
            end do
         end do
      end if !c13

      if ( use_c14 )then
         do i = 1,ndecomp_pools
            do j = 1, nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  matrix_Cinter14%V(c,j+(i-1)*nlevdecomp)   = cs14_soil%decomp_cpools_vr_col(c,j,i)
               end do
            end do
         end do
      end if !c14
      call t_stopf('CN Soil matrix-assign matrix-inter')

  ! Save the C and N pool size at begin of each year, which are used to calculate C and N capacity at end of each year.
      call t_startf('CN Soil matrix-assign matrix-decomp0')
      if (isbegofyear)then  
         do i = 1,ndecomp_pools
            do j = 1, nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  cs_soil%decomp0_cpools_vr_col(c,j,i)=cs_soil%decomp_cpools_vr_col(c,j,i)
                  ns_soil%decomp0_npools_vr_col(c,j,i)=ns_soil%decomp_npools_vr_col(c,j,i)
               end do
            end do
         end do
         where(cs_soil%decomp0_cpools_vr_col .lt. epsi)
            cs_soil%decomp0_cpools_vr_col = epsi
         end where
         where(ns_soil%decomp0_npools_vr_col .lt. epsi)
            ns_soil%decomp0_npools_vr_col = epsi
         end where
      end if
      call t_stopf('CN Soil matrix-assign matrix-decomp0')
   
  ! Set C transfer matrix Ac from a_ma_vr
      call t_startf('CN Soil matrix-matrix mult1-lev3-SetValueAK1')
      call AKsoilc%SetValueA(begc,endc,num_soilc,filter_soilc,a_ma_vr,A_i,A_j,Ntrans,init_readyAsoilc,list_Asoilc,RI_a,CI_a)
      call t_stopf('CN Soil matrix-matrix mult1-lev3-SetValueAK1')

  ! Set N transfer matrix An from na_ma_vr
      call t_startf('CN Soil matrix-matrix mult1-lev3-SetValueAK2')
      call AKsoiln%SetValueA(begc,endc,num_soilc,filter_soilc,na_ma_vr,A_i,A_j,Ntrans,init_readyAsoiln,list_Asoiln,RI_na,CI_na)
      call t_stopf('CN Soil matrix-matrix mult1-lev3-SetValueAK2')

  ! calculate matrix Ac*K for C
      call t_startf('CN Soil matrix-matrix mult1-lev3-SPMM_AK1')
      call AKsoilc%SPMM_AK(num_soilc,filter_soilc,Ksoil)
      call t_stopf('CN Soil matrix-matrix mult1-lev3-SPMM_AK1')

  ! calculate matrix An*K for N
      call t_startf('CN Soil matrix-matrix mult1-lev3-SPMM_AK2')
      call AKsoiln%SPMM_AK(num_soilc,filter_soilc,Ksoil)
      call t_stopf('CN Soil matrix-matrix mult1-lev3-SPMM_AK2')

  ! Set vertical transfer matrix V from tri_ma_vr
      call t_startf('CN Soil matrix-matrix mult1-lev3-SetValueAV,AKfire')
      call AVsoil%SetValueSM(begc,endc,num_soilc,filter_soilc,tri_ma_vr(begc:endc,1:Ntri_setup),tri_i,tri_j,Ntri_setup)

  ! Set fire decomposition matrix Kfire from matrix_decomp_fire_k
      do j=1,ndecomp_pools_vr
         kfire_i(j) = j
         kfire_j(j) = j
      end do
      call AKfiresoil%SetValueSM(begc,endc,num_soilc,filter_soilc,matrix_decomp_fire_k(begc:endc,1:ndecomp_pools_vr),kfire_i,kfire_j,ndecomp_pools_vr)
      call t_stopf('CN Soil matrix-matrix mult1-lev3-SetValueAV,AKfire')

  ! Calculate AKallsoilc = A*K + AVsoil + AKfiresoil. (AKfiresoil = -Kfire)
  ! When no fire, AKallsoilc = A*K + AVsoil
  ! When fire is on, AKallsoilc = A*K + AVsoil + AKfiresoil
  ! Here, AKallsoilc represents all soil C transfer rate (gC/(gC*m3*step))
  ! and AKallsoiln represents all soil N transfer rate (gN/(gN*m3*step))
      call t_startf('CN Soil matrix-matrix mult1-lev3-SPMP_AB')
      if(num_actfirec .eq. 0)then
         call AKallsoilc%SPMP_AB(num_soilc,filter_soilc,AKsoilc,AVsoil,list_ready1_nofire,list_A=list_AK_AKV, list_B=list_V_AKV,&
              NE_AB=NE_AKallsoilc,RI_AB=RI_AKallsoilc,CI_AB=CI_AKallsoilc)
         call AKallsoiln%SPMP_AB(num_soilc,filter_soilc,AKsoiln,AVsoil,list_ready2_nofire,list_A=list_AK_AKV, list_B=list_V_AKV,&
              NE_AB=NE_AKallsoiln,RI_AB=RI_AKallsoiln,CI_AB=CI_AKallsoiln)
      else
         call AKallsoilc%SPMP_ABC(num_soilc,filter_soilc,AKsoilc,AVsoil,AKfiresoil,list_ready1_fire,list_A=list_AK_AKVfire,&
              list_B=list_V_AKVfire,list_C=list_fire_AKVfire,NE_ABC=NE_AKallsoilc,RI_ABC=RI_AKallsoilc,CI_ABC=CI_AKallsoilc,&
              use_actunit_list_C=.True.,num_actunit_C=num_actfirec,filter_actunit_C=filter_actfirec)
         call AKallsoiln%SPMP_ABC(num_soilc,filter_soilc,AKsoiln,AVsoil,AKfiresoil,list_ready2_fire,list_A=list_AK_AKVfire,&
              list_B=list_V_AKVfire,list_C=list_fire_AKVfire,NE_ABC=NE_AKallsoiln,RI_ABC=RI_AKallsoiln,CI_ABC=CI_AKallsoiln,&
              use_actunit_list_C=.True.,num_actunit_C=num_actfirec,filter_actunit_C=filter_actfirec)
      end if

      call t_stopf('CN Soil matrix-matrix mult1-lev3-SPMP_AB')

      call t_startf('CN Soil matrix-matrix mult2-lev2')

  ! Update soil C pool size: X(matrix_Cinter) = X(matrix_Cinter) + (A*K + AVsoil + AKfiresoil) * X(matrix_Cinter)
  ! Update soil N pool size: X(matrix_Ninter) = X(matrix_Ninter) + (A*K + AVsoil + AKfiresoil) * X(matrix_Ninter)
      call matrix_Cinter%SPMM_AX(num_soilc,filter_soilc,AKallsoilc)
      call matrix_Ninter%SPMM_AX(num_soilc,filter_soilc,AKallsoiln)

  ! Update soil C13 pool size: X(matrix_Cinter13) = X(matrix_Cinter13) + (A*K + AVsoil + AKfiresoil) * X(matrix_Cinter13)
      if ( use_c13)then
         call matrix_Cinter13%SPMM_AX(num_soilc,filter_soilc,AKallsoilc)
      end if

  ! Update soil C14 pool size: X(matrix_Cinter14) = X(matrix_Cinter14) + (A*K + AVsoil + AKfiresoil) * X(matrix_Cinter14)
      if ( use_c14)then
         call matrix_Cinter14%SPMM_AX(num_soilc,filter_soilc,AKallsoilc)
      end if

  ! Update soil C pool size: X(matrix_Cinter) = X(matrix_Cinter) + (A*K + AVsoil + AKfiresoil) * X(matrix_Cinter) + I(matrix_Cinput)
  ! Update soil N pool size: X(matrix_Ninter) = X(matrix_Ninter) + (A*K + AVsoil + AKfiresoil) * X(matrix_Ninter) + I(matrix_Ninput)
      do j = 1, ndecomp_pools_vr
         do fc = 1,num_soilc
            c = filter_soilc(fc)
            matrix_Cinter%V(c,j) = matrix_Cinput%V(c,j) + matrix_Cinter%V(c,j)
            matrix_Ninter%V(c,j) = matrix_Ninput%V(c,j) + matrix_Ninter%V(c,j)
         end do
      end do

  ! Update soil C13 pool size: X(matrix_Cinter13) = X(matrix_Cinter13) + (A*K + AVsoil + AKfiresoil) * X(matrix_Cinter13) + I(matrix_Cinput13)
      if ( use_c13)then
         do j = 1, ndecomp_pools_vr
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               matrix_Cinter13%V(c,j) = matrix_Cinput13%V(c,j) + matrix_Cinter13%V(c,j)
            end do
         end do
      end if     
 
  ! Update soil C14 pool size: X(matrix_Cinter14) = X(matrix_Cinter14) + (A*K + AVsoil + AKfiresoil) * X(matrix_Cinter14) + I(matrix_Cinput14)
      if ( use_c14)then
         do j = 1, ndecomp_pools_vr
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               matrix_Cinter14%V(c,j) = matrix_Cinput14%V(c,j) + matrix_Cinter14%V(c,j)
            end do
         end do
      end if !c14

  ! Adjust heterotrophic respiration and fire flux because the pool size updating order is different between default and matrix code, balance error will occur
  ! while sudden big changes happen in C pool, eg. crop harvest and fire.
      call t_stopf('CN Soil matrix-matrix mult2-lev2')
      do i=1,ndecomp_pools
         do j=1,nlevdecomp
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               hr(c) = hr(c) - (matrix_Cinter%V(c,j+(i-1)*nlevdecomp)-Cinter_old(c,j+(i-1)*nlevdecomp)&
                              - matrix_Cinput%V(c,j+(i-1)*nlevdecomp))*dzsoi_decomp(j) / dt
            end do
         end do
      end do


      if(num_actfirec .ne. 0)then
         do i=1,ndecomp_pools
            do j=1,nlevdecomp
               do fc = 1,num_actfirec
                  c = filter_actfirec(fc)
                  fire_delta = AKfiresoil%M(c,j+(i-1)*nlevdecomp)*Cinter_old(c,j+(i-1)*nlevdecomp)*dzsoi_decomp(j) / dt 
                  m_decomp_cpools_to_fire(c,i) = m_decomp_cpools_to_fire(c,i) - fire_delta
                  hr(c) = hr(c) + fire_delta
               end do
            end do
         end do
      end if

      call t_startf('CN Soil matrix-assign back')

  ! Send vector type soil C and N pool size back to decomp_cpools_vr_col and decomp_npools_vr_col
      do i=1,ndecomp_pools
         do j = 1,nlevdecomp
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               cs_soil%decomp_cpools_vr_col(c,j,i) = matrix_Cinter%V(c,j+(i-1)*nlevdecomp)
               ns_soil%decomp_npools_vr_col(c,j,i) = matrix_Ninter%V(c,j+(i-1)*nlevdecomp)
            end do
         end do
      end do
          
      if( use_c13 ) then
         do i=1,ndecomp_pools
            do j = 1,nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  cs13_soil%decomp_cpools_vr_col(c,j,i) = matrix_Cinter13%V(c,j+(i-1)*nlevdecomp)
               end do
            end do
         end do
      end if

      if( use_c14 ) then
         do i=1,ndecomp_pools
            do j = 1,nlevdecomp
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  cs14_soil%decomp_cpools_vr_col(c,j,i) = matrix_Cinter14%V(c,j+(i-1)*nlevdecomp)
               end do
            end do
         end do
      end if

      call t_stopf('CN Soil matrix-assign back')

      if(use_soil_matrixcn .and. (is_outmatrix .or. isspinup))then
         call t_startf('CN Soil matrix-spinup & output1')
            
   ! Accumulate C transfers during a whole calendar year to calculate the C and N capacity
         do j=1,ndecomp_pools*nlevdecomp
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               cs_soil%in_acc (c,j) = cs_soil%in_acc (c,j) + matrix_Cinput%V(c,j)
               ns_soil%in_nacc(c,j) = ns_soil%in_nacc(c,j) + matrix_Ninput%V(c,j)
            end do
         end do

   ! Calculate all the soil N transfers in current time step
   ! After this step, AKallsoiln represents all the N transfers (gN/m3/step)
         call t_stopf('CN Soil matrix-spinup & output1')
         call Xdiagsoil%SetValueDM(begc,endc,num_soilc,filter_soilc,Ninter_old(begc:endc,1:ndecomp_pools_vr))
         call t_startf('CN Soil matrix-spinup & output1.5')

         call AKallsoiln%SPMM_AK(num_soilc,filter_soilc,Xdiagsoil)
         call t_stopf('CN Soil matrix-spinup & output1.5')

   ! Calculate all the soil C transfers in current time step. 
   ! After this step, AKallsoilc represents all the C transfers (gC/m3/step)
         call Xdiagsoil%SetValueDM(begc,endc,num_soilc,filter_soilc,Cinter_old(begc:endc,1:ndecomp_pools_vr))
         call t_startf('CN Soil matrix-spinup & output1.6')
         call AKallsoilc%SPMM_AK(num_soilc,filter_soilc,Xdiagsoil)
         call t_stopf('CN Soil matrix-spinup & output1.6')
        
   ! Accumulate soil N transfers: AKXnacc = AKXnacc + AKallsoiln
         call t_startf('CN Soil matrix-spinup & output2')
         call AKXnacc%SPMP_B_ACC(num_soilc,filter_soilc,AKallsoiln)
         call t_stopf('CN Soil matrix-spinup & output2')

   ! Accumulate soil N transfers: AKXnacc = AKXnacc + AKallsoiln
         call t_startf('CN Soil matrix-spinup & output3')
         call AKXcacc%SPMP_B_ACC(num_soilc,filter_soilc,AKallsoilc)
         call t_stopf('CN Soil matrix-spinup & output3')


         call t_startf('CN Soil matrix-calc. C capacity')
         if(is_end_curr_year())then
   ! Copy C transfers from sparse matrix to 2D temporary variables tran_acc and tran_nacc
   ! Calculate the C and N transfer rate by dividing CN transfer by base value saved at begin of each year.
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               cs_soil%tran_acc (c,1:ndecomp_pools_vr,1:ndecomp_pools_vr) = 0._r8
               ns_soil%tran_nacc(c,1:ndecomp_pools_vr,1:ndecomp_pools_vr) = 0._r8
            end do
            do j=1,n_all_entries
               j_lev    = mod(all_j(j)-1,nlevdecomp)+1
               j_decomp = (all_j(j) - j_lev)/nlevdecomp + 1
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  cs_soil%tran_acc(c,all_i(j),all_j(j))  = AKXcacc%M(c,j) / cs_soil%decomp0_cpools_vr_col(c,j_lev,j_decomp)
                  ns_soil%tran_nacc(c,all_i(j),all_j(j)) = AKXnacc%M(c,j) / ns_soil%decomp0_npools_vr_col(c,j_lev,j_decomp)
               end do
            end do

            do i=1,ndecomp_pools_vr
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  if (abs(cs_soil%tran_acc(c,i,i)) .le. epsi)then !avoid inversion nan
                      cs_soil%tran_acc(c,i,i) = 1.e+36_r8
                  end if 
               end do
            end do

            do i=1,ndecomp_pools_vr
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  if (abs(ns_soil%tran_nacc(c,i,i)) .le. epsi)then
                     ns_soil%tran_nacc(c,i,i) = 1.e+36_r8
                  end if 
               end do
            end do

   ! Calculate capacity 
            do fc = 1,num_soilc
               c = filter_soilc(fc)
               call inverse(cs_soil%tran_acc(c,1:ndecomp_pools_vr,1:ndecomp_pools_vr),AKinv(1:ndecomp_pools_vr,1:ndecomp_pools_vr),ndecomp_pools_vr)
               call inverse(ns_soil%tran_nacc(c,1:ndecomp_pools_vr,1:ndecomp_pools_vr),AKinvn(1:ndecomp_pools_vr,1:ndecomp_pools_vr),ndecomp_pools_vr)
               soilmatrixc_cap(c,:,1) = -matmul(AKinv(1:ndecomp_pools_vr,1:ndecomp_pools_vr),cs_soil%in_acc(c,1:ndecomp_pools_vr))
               soilmatrixn_cap(c,:,1) = -matmul(AKinvn(1:ndecomp_pools_vr,1:ndecomp_pools_vr),ns_soil%in_nacc(c,1:ndecomp_pools_vr))
            end do
         
   ! If spin up is on, the capacity replaces the pool size with capacity.
   ! Copy the capacity into a 3D variable, and be ready to write to history files.
            do i=1,ndecomp_pools
               do j = 1,nlevdecomp
                  do fc = 1,num_soilc
                     c = filter_soilc(fc)
                     if(isspinup)then
                        cs_soil%decomp_cpools_vr_col(c,j,i) =  soilmatrixc_cap(c,j+(i-1)*nlevdecomp,1)
                        ns_soil%decomp_npools_vr_col(c,j,i) =  soilmatrixn_cap(c,j+(i-1)*nlevdecomp,1)
                     end if
                     cs_soil%matrix_cap_decomp_cpools_vr_col(c,j,i) = soilmatrixc_cap(c,j+(i-1)*nlevdecomp,1)
                     ns_soil%matrix_cap_decomp_npools_vr_col(c,j,i) = soilmatrixn_cap(c,j+(i-1)*nlevdecomp,1)
                  end do
               end do
            end do

   ! Reset to accumulation variables to 0 at end of each year
            do j=1,n_all_entries
               do fc = 1,num_soilc
                  c = filter_soilc(fc)
                  AKXcacc%M(c,j) = 0._r8
                  AKXnacc%M(c,j) = 0._r8
               end do
            end do

            do fc = 1,num_soilc
               c = filter_soilc(fc)
               cs_soil%in_acc   (c,:)   = 0._r8
               ns_soil%in_nacc  (c,:)   = 0._r8
            end do
         end if
         call t_stopf('CN Soil matrix-calc. C capacity')
      end if !is out_matrix

   end associate 
 end subroutine CNSoilMatrix
 
 subroutine inverse(a,c,n)
!============================================================
! Inverse matrix
! Method: Based on Doolittle LU factorization for Ax=b
! Alex G. December 2009
!-----------------------------------------------------------
! input ...
! a(n,n) - array of coefficients for matrix A
! n      - dimension
! output ...
! c(n,n) - inverse matrix of A
! comments ...
! the original matrix a(n,n) will be destroyed
! during the calculation
!===========================================================
implicit none
integer,intent(in) :: n
real(r8),intent(in)  :: a(n,n)
real(r8),intent(out) :: c(n,n)
real(r8) :: L(n,n), U(n,n), aa(n,n), b(n), d(n), x(n)
real(r8) :: coeff
integer i, j, k

! step 0: initialization for matrices L and U and b
! Fortran 90/95 aloows such operations on matrices
L=0.0
U=0.0
b=0.0

aa=a
! step 1: forward elimination
do k=1, n-1
   do i=k+1,n
      coeff=aa(i,k)/aa(k,k)
      L(i,k) = coeff
      do j=k+1,n
         aa(i,j) = aa(i,j)-coeff*aa(k,j)
      end do
   end do
end do

! Step 2: prepare L and U matrices
! L matrix is a matrix of the elimination coefficient
! + the diagonal elements are 1.0
do i=1,n
  L(i,i) = 1.0
end do
! U matrix is the upper triangular part of A
do j=1,n
  do i=1,j
    U(i,j) = aa(i,j)
  end do
end do

! Step 3: compute columns of the inverse matrix C
do k=1,n
  b(k)=1.0
  d(1) = b(1)
! Step 3a: Solve Ld=b using the forward substitution
  do i=2,n
    d(i)=b(i)
    do j=1,i-1
      d(i) = d(i) - L(i,j)*d(j)
    end do
  end do
! Step 3b: Solve Ux=d using the back substitution
  x(n)=d(n)/U(n,n)
  do i = n-1,1,-1
    x(i) = d(i)
    do j=n,i+1,-1
      x(i)=x(i)-U(i,j)*x(j)
    end do
    x(i) = x(i)/u(i,i)
  end do
! Step 3c: fill the solutions x(n) into column k of C
  do i=1,n
    c(i,k) = x(i)
  end do
  b(k)=0.0
end do
end subroutine inverse

end module CNSoilMatrixMod


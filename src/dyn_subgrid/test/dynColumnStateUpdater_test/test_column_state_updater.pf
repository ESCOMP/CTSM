module test_column_state_updater

  ! Tests of dynColumnStateUpdaterMod

  use funit
  use dynColumnStateUpdaterMod
  use shr_kind_mod , only : r8 => shr_kind_r8
  use unittestSubgridMod
  use landunit_varcon, only : istsoil, max_lunit
  use pftconMod, only : noveg
  use ColumnType
  use LandunitType
  use subgridWeightsMod, only : compute_higher_order_weights

  implicit none

  @TestCase
  type, extends(TestCase) :: TestColumnStateUpdater
     ! The following arrays have lower bound 1, rather than bounds%begc
     real(r8), allocatable :: cwtgcell_old(:)
     real(r8), allocatable :: cwtgcell_new(:)
     real(r8), allocatable :: cwtgcell_new_minus_old(:)
   contains
     procedure :: setUp
     procedure :: tearDown
     procedure :: setup_gridcell_with_four_vegetated_columns
     procedure :: setup_gridcell_with_two_vegetated_columns_and_special
     procedure :: setup_three_gridcells_with_two_columns_each
     procedure :: setup_grid_end  ! do stuff at the end of setting up the grid
     procedure :: set_new_cwtlunit
     procedure :: set_new_lwtgcell
     procedure :: set_new_weights_end  ! do stuff at the end of setting new weights
     procedure :: do_all_setup_with_four_vegetated_columns
     procedure :: do_all_setup_with_two_vegetated_columns_and_special
     procedure :: do_all_setup_two_veg_and_special_specialShrinks
     procedure :: do_all_setup_two_veg_and_special_specialGrows
     procedure :: assertConservation
  end type TestColumnStateUpdater

  real(r8), parameter :: tol = 1.e-13_r8

contains

  ! ========================================================================
  ! Helper routines
  ! ========================================================================

  subroutine setUp(this)
    class(TestColumnStateUpdater), intent(inout) :: this
  end subroutine setUp

  subroutine tearDown(this)
    class(TestColumnStateUpdater), intent(inout) :: this

    call unittest_subgrid_teardown()
  end subroutine tearDown

  subroutine setup_gridcell_with_four_vegetated_columns(this, cwtlunit)
    ! Sets up a grid with one gridcell, with a single vegetated landunit, with four
    ! vegetated columns (each with one patch)
    class(TestColumnStateUpdater), intent(inout) :: this
    real(r8), intent(in) :: cwtlunit(:)  ! weight of each column on the landunit (must be size 4)

    @assertEqual(4, size(cwtlunit))

    call unittest_subgrid_setup_start()
    call unittest_add_gridcell()
    call unittest_add_landunit(my_gi=gi, ltype=istsoil, wtgcell=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit(1))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit(2))
    call unittest_add_patch(my_ci=ci, ptype=2, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit(3))
    call unittest_add_patch(my_ci=ci, ptype=3, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit(4))
    call unittest_add_patch(my_ci=ci, ptype=4, wtcol=1.0_r8)
    call unittest_subgrid_setup_end()

    call this%setup_grid_end()
  end subroutine setup_gridcell_with_four_vegetated_columns

  subroutine setup_gridcell_with_two_vegetated_columns_and_special(this, &
       lwtgcell, cwtlunit_veg, special_type)
    ! Sets up a grid with one gridcell, with (1) a vegetated landunit with two columns,
    ! and (2) a special landunit with one column. (Each column has one patch)
    class(TestColumnStateUpdater), intent(inout) :: this

    ! weight of each landunit on the gridcell; must be size 2
    ! index 1: natural veg; index 2: special
    real(r8), intent(in) :: lwtgcell(:)

    ! weight of each column on the natural veg landunit; must be size 2
    real(r8), intent(in) :: cwtlunit_veg(:)

    ! landunit type of the special landunit
    integer, intent(out) :: special_type

    @assertEqual(2, size(lwtgcell))
    @assertEqual(sum(lwtgcell), 1.0_r8, tolerance=tol)
    @assertEqual(2, size(cwtlunit_veg))
    @assertEqual(sum(cwtlunit_veg), 1.0_r8, tolerance=tol)

    call unittest_subgrid_setup_start()
    call unittest_add_gridcell()

    call unittest_add_landunit(my_gi=gi, ltype=istsoil, wtgcell=lwtgcell(1))
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_veg(1))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_veg(2))
    call unittest_add_patch(my_ci=ci, ptype=2, wtcol=1.0_r8)

    special_type = get_ltype_special()
    call unittest_add_landunit(my_gi=gi, ltype=special_type, wtgcell=lwtgcell(2))
    call unittest_add_column(my_li=li, ctype=1, wtlunit=1.0_r8)
    call unittest_add_patch(my_ci=ci, ptype=noveg, wtcol=1.0_r8)

    call unittest_subgrid_setup_end()

    call this%setup_grid_end()
  end subroutine setup_gridcell_with_two_vegetated_columns_and_special

  subroutine setup_three_gridcells_with_two_columns_each(this, &
       cwtlunit_grc1, cwtlunit_grc2, cwtlunit_grc3)
    ! Sets up a grid with three grid cells, each with a single vegetated landunit with two
    ! vegetated columns (each with one patch)
    class(TestColumnStateUpdater), intent(inout) :: this
    ! weight of each column on the vegetated landunit, in each grid cell (each must be size 2)
    real(r8), intent(in) :: cwtlunit_grc1(:)
    real(r8), intent(in) :: cwtlunit_grc2(:)
    real(r8), intent(in) :: cwtlunit_grc3(:)

    @assertEqual(2, size(cwtlunit_grc1))
    @assertEqual(2, size(cwtlunit_grc2))

    call unittest_subgrid_setup_start()

    call unittest_add_gridcell()
    call unittest_add_landunit(my_gi=gi, ltype=istsoil, wtgcell=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_grc1(1))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_grc1(2))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)

    call unittest_add_gridcell()
    call unittest_add_landunit(my_gi=gi, ltype=istsoil, wtgcell=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_grc2(1))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_grc2(2))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)

    call unittest_add_gridcell()
    call unittest_add_landunit(my_gi=gi, ltype=istsoil, wtgcell=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_grc3(1))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)
    call unittest_add_column(my_li=li, ctype=1, wtlunit=cwtlunit_grc3(2))
    call unittest_add_patch(my_ci=ci, ptype=1, wtcol=1.0_r8)

    call unittest_subgrid_setup_end()

    call this%setup_grid_end()
  end subroutine setup_three_gridcells_with_two_columns_each

  subroutine setup_grid_end(this)
    ! Does necessary stuff at the end of setting up the subgrid structure
    class(TestColumnStateUpdater), intent(inout) :: this

    this%cwtgcell_old = col%wtgcell(bounds%begc:bounds%endc)
  end subroutine setup_grid_end

  subroutine set_new_cwtlunit(this, cwtlunit)
    ! Sets new subgrid weights based on new cwtlunit values
    class(TestColumnStateUpdater), intent(inout) :: this
    real(r8), intent(in) :: cwtlunit(bounds%begc:)  ! weight of each column on the landunit

    integer :: c

    @assertEqual(bounds%endc, ubound(cwtlunit, 1))

    do c = bounds%begc, bounds%endc
       col%wtlunit(c) = cwtlunit(c)
    end do

    call this%set_new_weights_end()
  end subroutine set_new_cwtlunit

  subroutine set_new_lwtgcell(this, lwtgcell)
    ! Sets new subgrid weights based on new lwtgcell values
    class(TestColumnStateUpdater), intent(inout) :: this
    real(r8), intent(in) :: lwtgcell(bounds%begl:)  ! weight of each landunit on the gridcell

    integer :: l

    @assertEqual(bounds%endl, ubound(lwtgcell, 1))

    do l = bounds%begl, bounds%endl
       lun%wtgcell(l) = lwtgcell(l)
    end do

    call this%set_new_weights_end()
  end subroutine set_new_lwtgcell

  subroutine set_new_weights_end(this)
    ! Does necessary stuff at the end of setting new subgrid weights
    class(TestColumnStateUpdater), intent(inout) :: this

    call compute_higher_order_weights(bounds)
    this%cwtgcell_new = col%wtgcell(bounds%begc:bounds%endc)
    this%cwtgcell_new_minus_old = this%cwtgcell_new - this%cwtgcell_old
  end subroutine set_new_weights_end

  subroutine do_all_setup_with_two_vegetated_columns_and_special( &
       this, cs_updater, lwtgcell_old, lwtgcell_new, cwtlunit_veg, special_type)
    ! Does all setup needed when setting up one grid cell with two vegetated columns and
    ! a special landunit
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type), intent(out) :: cs_updater
    real(r8), intent(in) :: lwtgcell_old(:)
    real(r8), intent(in) :: lwtgcell_new(:)
    real(r8), intent(in) :: cwtlunit_veg(:)  ! assumed not to change

    integer, intent(out), optional :: special_type  ! type of the special landunit

    integer :: l_special_type

    call this%setup_gridcell_with_two_vegetated_columns_and_special( &
         lwtgcell = lwtgcell_old, &
         cwtlunit_veg = cwtlunit_veg, &
         special_type = l_special_type)
    if (present(special_type)) then
       special_type = l_special_type
    end if
    cs_updater = column_state_updater_type(bounds, nclumps=1)
    call cs_updater%set_old_weights(bounds)

    call this%set_new_lwtgcell(lwtgcell = lwtgcell_new)
    call cs_updater%set_new_weights(bounds, clump_index=1)
  end subroutine do_all_setup_with_two_vegetated_columns_and_special

  subroutine do_all_setup_two_veg_and_special_specialShrinks( &
       this, cs_updater, special_type)
    ! Does all setup needed when setting up one grid cell with two vegetated columns and
    ! a special landunit, with the special landunit shrinking, and the vegetated landunit
    ! growing (with the two vegetated columns growing in equal proportion).
    !
    ! There are three columns: the first two are vegetated, the last is special.
    !
    ! This hard-codes the old and new weights for convenience. Relevant weights can be
    ! accessed via the class's cwtgcell_old and cwtgcell_new variables.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type), intent(out) :: cs_updater
    integer, intent(out), optional :: special_type  ! type of the special landunit

    ! weight of veg & special landunits
    real(r8), parameter :: lwtgcell_old(2) = [0.4_r8, 0.6_r8]
    real(r8), parameter :: lwtgcell_new(2) = [0.7_r8, 0.3_r8]

    ! weight of each veg column (constant in time)
    real(r8), parameter :: cwtlunit_veg(2) = [0.2_r8, 0.8_r8]

    call this%do_all_setup_with_two_vegetated_columns_and_special( &
         cs_updater, &
         lwtgcell_old = lwtgcell_old, &
         lwtgcell_new = lwtgcell_new, &
         cwtlunit_veg = cwtlunit_veg, &
         special_type = special_type)
  end subroutine do_all_setup_two_veg_and_special_specialShrinks

  subroutine do_all_setup_two_veg_and_special_specialGrows( &
       this, cs_updater, special_type)
    ! Does all setup needed when setting up one grid cell with two vegetated columns and
    ! a special landunit, with the special landunit growing, and the vegetated landunit
    ! shrinking (with the two vegetated columns shrinking in equal proportion).
    !
    ! There are three columns: the first two are vegetated, the last is special.
    !
    ! This hard-codes the old and new weights for convenience. Relevant weights can be
    ! accessed via the class's cwtgcell_old and cwtgcell_new variables.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type), intent(out) :: cs_updater
    integer, intent(out), optional :: special_type  ! type of the special landunit

    ! weight of veg & special landunits
    real(r8), parameter :: lwtgcell_old(2) = [0.4_r8, 0.6_r8]
    real(r8), parameter :: lwtgcell_new(2) = [0.1_r8, 0.9_r8]

    ! weight of each veg column (constant in time)
    real(r8), parameter :: cwtlunit_veg(2) = [0.2_r8, 0.8_r8]

    call this%do_all_setup_with_two_vegetated_columns_and_special( &
         cs_updater, &
         lwtgcell_old = lwtgcell_old, &
         lwtgcell_new = lwtgcell_new, &
         cwtlunit_veg = cwtlunit_veg, &
         special_type = special_type)
  end subroutine do_all_setup_two_veg_and_special_specialGrows

  subroutine do_all_setup_with_four_vegetated_columns( &
       this, cs_updater, cwtlunit_old, cwtlunit_new)
    ! Does all setup needed when setting up one grid cell with four vegetated columns
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type), intent(out) :: cs_updater
    real(r8), intent(in) :: cwtlunit_old(:)
    real(r8), intent(in) :: cwtlunit_new(:)

    call this%setup_gridcell_with_four_vegetated_columns(cwtlunit_old)
    cs_updater = column_state_updater_type(bounds, nclumps=1)
    call cs_updater%set_old_weights(bounds)

    call this%set_new_cwtlunit(cwtlunit_new)
    call cs_updater%set_new_weights(bounds, clump_index=1)
  end subroutine do_all_setup_with_four_vegetated_columns


  subroutine assertConservation(this, var_old, var_new, msg, &
       begc, endc, non_conserved_mass)
    ! Asserts that the transformation for a given grid cell was conservative
    class(TestColumnStateUpdater), intent(in) :: this
    real(r8), intent(in) :: var_old(:)
    real(r8), intent(in) :: var_new(:)
    character(len=*), intent(in) :: msg

    ! Provide these optional arguments if you just want to check a subset of columns.
    !
    ! This is useful if there are multiple grid cells: in this case, provide the begc &
    ! endc of the grid cell of interest.
    !
    ! This is also useful if the conservation check should exclude certain columns (e.g.,
    ! if special columns should be excluded from the conservation check).
    !
    ! These assume 1-indexing - i.e., the index of the first column is 1
    integer, intent(in), optional :: begc
    integer, intent(in), optional :: endc

    ! Non-conserved mass in this grid cell: we make sure that conservation occurs once
    ! you account for this known non-conserved mass
    real(r8), intent(in), optional :: non_conserved_mass

    character(len=:), allocatable :: full_msg
    integer :: my_begc, my_endc
    real(r8) :: sum_old, sum_new

    if (present(begc)) then
       my_begc = begc
    else
       my_begc = 1
    end if

    if (present(endc)) then
       my_endc = endc
    else
       my_endc = bounds%endc - bounds%begc + 1
    end if

    full_msg = trim(msg)//': conservation'

    sum_old = sum(this%cwtgcell_old(my_begc:my_endc) * var_old(my_begc:my_endc))
    sum_new = sum(this%cwtgcell_new(my_begc:my_endc) * var_new(my_begc:my_endc))
    if (present(non_conserved_mass)) then
       sum_new = sum_new + non_conserved_mass
    end if
    @assertEqual(sum_old, sum_new, tolerance=tol, message=full_msg)
  end subroutine assertConservation

  ! ========================================================================
  ! Begin actual unit tests
  ! ========================================================================

  @Test
  subroutine noSpecialHandling_noAreaChange(this)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8) :: myvar(4)
    real(r8) :: expected(4)

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8], &
         cwtlunit_new = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8])

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    expected = myvar

    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar)

    @assertEqual(expected, myvar)
  end subroutine noSpecialHandling_noAreaChange

  @Test
  subroutine noSpecialHandling_oneShrinksOneGrows(this)
    ! This tests one column shrinking, one growing, and two staying the same in area
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.05_r8, 0.2_r8, 0.35_r8, 0.4_r8]
    real(r8) :: myvar(4), myvar_orig(4), expected(4)

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    myvar_orig = myvar
    expected = myvar
    expected(3) = (cwtlunit_old(3)*myvar(3) + this%cwtgcell_new_minus_old(3)*myvar(1)) / &
         cwtlunit_new(3)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar)

    ! Verify
    ! First make sure that the transformation is conservative; note that this looks at the
    ! expected values, rather than the actual result, so this is mainly about making sure
    ! that we set things up correctly - but it also confirms that the routine conserves
    ! mass as long as the actual result matches the expected result
    call this%assertConservation(myvar_orig, expected, 'noSpecialHandling_oneShrinksOneGrows')
    ! Now make sure that we got the right answer
    @assertEqual(expected, myvar, tolerance=tol)
  end subroutine noSpecialHandling_oneShrinksOneGrows

  @Test
  subroutine noSpecialHandling_twoShrinkTwoGrow(this)
    ! This tests one column shrinking to 0 area, one shrinking to non-zero area, one
    ! growing from 0 area, and one growing from non-zero area
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8,  0._r8,   0.7_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0._r8 , 0.15_r8, 0.08_r8, 0.77_r8]
    real(r8), parameter :: new_minus_old(4) = cwtlunit_new - cwtlunit_old
    real(r8) :: mass_gain_per_unit_area
    real(r8) :: myvar(4), myvar_orig(4), expected(4)

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    myvar_orig = myvar
    expected(1:2) = myvar(1:2)
    mass_gain_per_unit_area = (new_minus_old(1) * myvar(1) + new_minus_old(2) * myvar(2)) / &
         (new_minus_old(1) + new_minus_old(2))
    expected(3) = mass_gain_per_unit_area
    expected(4) = (cwtlunit_old(4)*myvar(4) + new_minus_old(4)*mass_gain_per_unit_area) / &
         cwtlunit_new(4)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar)

    ! Verify
    ! First make sure that the transformation is conservative; note that this looks at the
    ! expected values, rather than the actual result, so this is mainly about making sure
    ! that we set things up correctly - but it also confirms that the routine conserves
    ! mass as long as the actual result matches the expected result
    call this%assertConservation(myvar_orig, expected, 'noSpecialHandling_twoShrinkTwoGrow')
    ! Now make sure that we got the right answer
    @assertEqual(expected, myvar, tolerance=tol)
  end subroutine noSpecialHandling_twoShrinkTwoGrow

  @Test
  subroutine noSpecialHandling_multipleGridCells(this)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    ! Grid cell 1: c1 shrinks, c2 grows
    real(r8), parameter :: cwtlunit_grc1_old(2) = [0.4_r8, 0.6_r8]
    real(r8), parameter :: cwtlunit_grc1_new(2) = [0.35_r8, 0.65_r8]
    ! Grid cell 2: constant areas
    real(r8), parameter :: cwtlunit_grc2_old(2) = [0.3_r8, 0.7_r8]
    real(r8), parameter :: cwtlunit_grc2_new(2) = cwtlunit_grc2_old
    ! Grid cell 3: c1 grows, c2 shrinks
    real(r8), parameter :: cwtlunit_grc3_old(2) = [0.2_r8, 0.8_r8]
    real(r8), parameter :: cwtlunit_grc3_new(2) = [0.9_r8, 0.1_r8]

    real(r8) :: g1_weight_change, g3_weight_change
    real(r8) :: myvar(6), myvar_orig(6), expected(6)

    ! Setup

    call this%setup_three_gridcells_with_two_columns_each( &
         cwtlunit_grc1_old, cwtlunit_grc2_old, cwtlunit_grc3_old)
    cs_updater = column_state_updater_type(bounds, nclumps=1)
    call cs_updater%set_old_weights(bounds)

    call this%set_new_cwtlunit(cwtlunit = &
         [cwtlunit_grc1_new, cwtlunit_grc2_new, cwtlunit_grc3_new])
    call cs_updater%set_new_weights(bounds, clump_index=1)

    myvar = [1._r8, 2._r8, 3._r8, 4._r8, 5._r8, 6._r8]
    myvar_orig = myvar
    expected = myvar

    ! c2 in grid cell 1:
    g1_weight_change = cwtlunit_grc1_new(2) - cwtlunit_grc1_old(2)
    expected(2) = (cwtlunit_grc1_old(2)*myvar(2) + g1_weight_change*myvar(1)) / &
         (cwtlunit_grc1_old(2) + g1_weight_change)

    ! c1 in grid cell 3:
    g3_weight_change = cwtlunit_grc3_new(1) - cwtlunit_grc3_old(1)
    expected(5) = (cwtlunit_grc3_old(1)*myvar(5) + g3_weight_change*myvar(6)) / &
         (cwtlunit_grc3_old(1) + g3_weight_change)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar)

    ! Verify
    ! First make sure that the transformation is conservative; note that this looks at the
    ! expected values, rather than the actual result, so this is mainly about making sure
    ! that we set things up correctly - but it also confirms that the routine conserves
    ! mass as long as the actual result matches the expected result
    call this%assertConservation(myvar_orig, expected, &
         'noSpecialHandling_multipleGridCells: grc1', begc=1, endc=2)
    call this%assertConservation(myvar_orig, expected, &
         'noSpecialHandling_multipleGridCells: grc2', begc=3, endc=4)
    call this%assertConservation(myvar_orig, expected, &
         'noSpecialHandling_multipleGridCells: grc3', begc=5, endc=6)
    ! Now make sure that we got the right answer
    @assertEqual(expected, myvar, tolerance=tol)
  end subroutine noSpecialHandling_multipleGridCells

  @Test
  subroutine fillSpecialUsingNatveg_specialShrinks(this)
    ! This tests a special column shrinking when using the routine that fills special
    ! points using natural veg as a template. In order to test that the template is
    ! applied correctly, we use two natural veg columns.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater

    real(r8) :: input_from_glacier
    real(r8) :: myvar(3), myvar_orig(3), expected_var(3)
    real(r8) :: expected_non_conserved_mass
    real(r8) :: non_conserved_mass_grc(1) = 0._r8

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialShrinks(cs_updater)

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    expected_var(3) = myvar(3)
    ! glacier uses column 1 as a template:
    input_from_glacier = myvar(1)
    ! column 1 doesn't change because the glacier input is the same as what's already there:
    expected_var(1) = myvar(1)
    expected_var(2) = (this%cwtgcell_old(2)*myvar(2) + &
         this%cwtgcell_new_minus_old(2)*input_from_glacier) / &
         this%cwtgcell_new(2)
    expected_non_conserved_mass = this%cwtgcell_new_minus_old(3) * input_from_glacier

    ! Exercise
    call cs_updater%update_column_state_fill_special_using_natveg(bounds, clump_index=1, var=myvar, &
         non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    @assertEqual(expected_var, myvar, tolerance=tol)
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)
    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    call this%assertConservation(myvar_orig, myvar, &
         'fillSpecialUsingNatveg_specialShrinks', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine fillSpecialUsingNatveg_specialShrinks

  @Test
  subroutine fillSpecialUsingNatveg_specialGrows(this)
    ! This tests a special column growing when using the routine that fills special
    ! points using natural veg as a template.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater

    real(r8) :: myvar(3), myvar_orig(3), expected_var(3)
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    real(r8) :: expected_non_conserved_mass

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialGrows(cs_updater)

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    ! the growing special point should not accept any mass, so should keep its original
    ! value
    expected_var = myvar
    expected_non_conserved_mass = -1._r8 * &
         (myvar(1) * this%cwtgcell_new_minus_old(1) + &
         myvar(2) * this%cwtgcell_new_minus_old(2))

    ! Exercise
    call cs_updater%update_column_state_fill_special_using_natveg(bounds, clump_index=1, var=myvar, &
         non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    @assertEqual(expected_var, myvar, tolerance=tol)
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)
    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    call this%assertConservation(myvar_orig, myvar, &
         'fillSpecialUsingNatveg_specialGrows', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine fillSpecialUsingNatveg_specialGrows

  @Test
  subroutine fillSpecialUsingNatveg_nonSpecial(this)
    ! This tests non-special columns growing and shrinking when using the routine that
    ! fills special points using natural veg as a template. This makes sure that
    ! non-special columns are treated normally by this routine.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.05_r8, 0.2_r8, 0.35_r8, 0.4_r8]
    real(r8) :: myvar(4), myvar_orig(4), expected(4)
    real(r8), parameter :: non_conserved_mass_orig = 2._r8
    real(r8) :: non_conserved_mass_grc(1) = non_conserved_mass_orig

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    myvar_orig = myvar
    expected = myvar
    expected(3) = (cwtlunit_old(3)*myvar(3) + this%cwtgcell_new_minus_old(3)*myvar(1)) / &
         cwtlunit_new(3)

    ! Exercise
    call cs_updater%update_column_state_fill_special_using_natveg(bounds, clump_index=1, var=myvar, &
         non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    ! First make sure that the transformation is conservative; note that this looks at the
    ! expected values, rather than the actual result, so this is mainly about making sure
    ! that we set things up correctly - but it also confirms that the routine conserves
    ! mass as long as the actual result matches the expected result
    call this%assertConservation(myvar_orig, expected, 'fillSpecialUsingNatveg_nonSpecial')
    ! Now make sure that we got the right answer
    @assertEqual(expected, myvar, tolerance=tol)
    @assertEqual(non_conserved_mass_orig, non_conserved_mass_grc(1))
  end subroutine fillSpecialUsingNatveg_nonSpecial

  @Test
  subroutine fillUsingFixedValues_specialShrinks(this)
    ! This tests a specially-handled column shrinking when using the routine that fills
    ! points using fixed values
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater

    integer :: special_type  ! landunit type of the special type
    real(r8), parameter :: input_from_special = 14._r8
    real(r8) :: landunit_values(max_lunit)
    real(r8) :: myvar(3), myvar_orig(3), expected_var(3)
    real(r8) :: expected_non_conserved_mass
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    integer :: i

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialShrinks( &
         cs_updater, &
         special_type = special_type)

    landunit_values(:) = FILLVAL_USE_EXISTING_VALUE
    landunit_values(special_type) = input_from_special

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    expected_var(3) = myvar(3)
    do i = 1, 2
       expected_var(i) = (this%cwtgcell_old(i)*myvar(i) + &
            this%cwtgcell_new_minus_old(i)*input_from_special) / &
            this%cwtgcell_new(i)
    end do
    expected_non_conserved_mass = this%cwtgcell_new_minus_old(3) * input_from_special

    ! Exercise
    call cs_updater%update_column_state_fill_using_fixed_values(bounds, clump_index=1, var=myvar, &
         landunit_values=landunit_values, non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    @assertEqual(expected_var, myvar, tolerance=tol)
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)
    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    call this%assertConservation(myvar_orig, myvar, &
         'fillUsingFixedValues_specialShrinks', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine fillUsingFixedValues_specialShrinks

  @Test
  subroutine fillUsingFixedValues_specialGrows(this)
    ! This tests a specially-handled column growing when using the routine that fills
    ! points using fixed values
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater

    integer :: special_type  ! landunit type of the special type
    real(r8), parameter :: input_from_special = 14._r8  ! irrelevant
    real(r8) :: landunit_values(max_lunit)
    real(r8) :: myvar(3), myvar_orig(3), expected_var(3)
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    real(r8) :: expected_non_conserved_mass
    integer :: i

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialGrows( &
         cs_updater, &
         special_type = special_type)

    landunit_values(:) = FILLVAL_USE_EXISTING_VALUE
    landunit_values(special_type) = input_from_special

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    ! the growing special point should not accept any mass, so should keep its original
    ! value
    expected_var = myvar
    expected_non_conserved_mass = -1._r8 * &
         (myvar(1) * this%cwtgcell_new_minus_old(1) + &
         myvar(2) * this%cwtgcell_new_minus_old(2))

    ! Exercise
    call cs_updater%update_column_state_fill_using_fixed_values(bounds, clump_index=1, var=myvar, &
         landunit_values=landunit_values, non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    @assertEqual(expected_var, myvar, tolerance=tol)
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)
    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    call this%assertConservation(myvar_orig, myvar, &
         'fillUsingFixedValues_specialGrows', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine fillUsingFixedValues_specialGrows

  @Test
  subroutine fillUsingFixedValues_nonSpecial(this)
    ! This tests non-special columns growing and shrinking when using the routine that
    ! fills special points using fixed values. This makes sure that non-special columns
    ! are treated normally by this routine.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.05_r8, 0.2_r8, 0.35_r8, 0.4_r8]
    real(r8) :: landunit_values(max_lunit)
    real(r8) :: myvar(4), myvar_orig(4), expected(4)
    real(r8), parameter :: non_conserved_mass_orig = 2._r8
    real(r8) :: non_conserved_mass_grc(1) = non_conserved_mass_orig

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    landunit_values(:) = FILLVAL_USE_EXISTING_VALUE

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    myvar_orig = myvar
    expected = myvar
    expected(3) = (cwtlunit_old(3)*myvar(3) + this%cwtgcell_new_minus_old(3)*myvar(1)) / &
         cwtlunit_new(3)

    ! Exercise
    call cs_updater%update_column_state_fill_using_fixed_values(bounds, clump_index=1, var=myvar, &
         landunit_values=landunit_values, non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    ! First make sure that the transformation is conservative; note that this looks at the
    ! expected values, rather than the actual result, so this is mainly about making sure
    ! that we set things up correctly - but it also confirms that the routine conserves
    ! mass as long as the actual result matches the expected result
    call this%assertConservation(myvar_orig, expected, 'fillUsingFixedValues_nonSpecial')
    ! Now make sure that we got the right answer
    @assertEqual(expected, myvar, tolerance=tol)
    @assertEqual(non_conserved_mass_orig, non_conserved_mass_grc(1))
  end subroutine fillUsingFixedValues_nonSpecial

  @Test
  subroutine fillSpecialUsingFixedValue_specialShrinks(this)
    ! This tests a specially-handled column shrinking when using the routine that fills
    ! all special points using a single fixed value. (No need to have multiple tests of
    ! this update_column_state_fill_special_using_fixed_value routine, since it is merely
    ! a lightweight wrapper to a different routine.)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater

    integer :: special_type  ! landunit type of the special type
    real(r8), parameter :: input_from_special = 14._r8
    real(r8) :: myvar(3), myvar_orig(3), expected_var(3)
    real(r8) :: expected_non_conserved_mass
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    integer :: i

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialShrinks( &
         cs_updater, &
         special_type = special_type)

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    expected_var(3) = myvar(3)
    do i = 1, 2
       expected_var(i) = (this%cwtgcell_old(i)*myvar(i) + &
            this%cwtgcell_new_minus_old(i)*input_from_special) / &
            this%cwtgcell_new(i)
    end do
    expected_non_conserved_mass = this%cwtgcell_new_minus_old(3) * input_from_special

    ! Exercise
    call cs_updater%update_column_state_fill_special_using_fixed_value(bounds, clump_index=1, var=myvar, &
         special_value=input_from_special, non_conserved_mass_grc=non_conserved_mass_grc)

    ! Verify
    @assertEqual(expected_var, myvar, tolerance=tol)
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)
    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    call this%assertConservation(myvar_orig, myvar, &
         'fillSpecialUsingFixedValue_specialShrinks', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine fillSpecialUsingFixedValue_specialShrinks


  ! ------------------------------------------------------------------------
  ! Tests with fractional_areas
  ! ------------------------------------------------------------------------

  @Test
  subroutine withFractionalAreas_oneShrinksOneGrows(this)
    ! This tests the updating of a variable with fractional area terms, with one column
    ! shrinking, one growing, and two staying the same in area
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.1_r8, 0.3_r8, 0.2_r8, 0.4_r8]
    real(r8), parameter :: fractional_area_old(4)  = [0.0_r8, 0.1_r8, 0.7_r8, 0.5_r8]
    real(r8) :: myvar(4), myvar_orig(4), expected(4), fractional_area_new(4)
    real(r8) :: myvar_orig_weighted(4), myvar_weighted(4)

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 7._r8, 8._r8]
    myvar_orig = myvar
    expected = myvar
    expected(2) = (this%cwtgcell_old(2) * fractional_area_old(2) * myvar(2) + &
         this%cwtgcell_new_minus_old(2) * fractional_area_old(3) * myvar(3)) / &
         (this%cwtgcell_old(2)*fractional_area_old(2) + &
         this%cwtgcell_new_minus_old(2) * fractional_area_old(3))

    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new)

    ! Verify
    @assertEqual(expected, myvar, tolerance=tol)
    myvar_orig_weighted = myvar_orig*fractional_area_old
    myvar_weighted = myvar*fractional_area_new
    call this%assertConservation(myvar_orig_weighted, myvar_weighted, 'withFractionalAreas_oneShrinksOneGrows')
  end subroutine withFractionalAreas_oneShrinksOneGrows

  @Test
  subroutine withFractionalAreas_fraction0_oneShrinksOneGrows(this)
    ! This tests the updating of a variable with fractional area terms, with one column
    ! shrinking, one growing, and two staying the same in area. Here the growing column
    ! has a new fractional area of 0.
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.1_r8, 0.3_r8, 0.2_r8, 0.4_r8]
    real(r8), parameter :: fractional_area_old(4)  = [0.0_r8, 0.0_r8, 0.0_r8, 0.5_r8]
    real(r8) :: myvar(4), myvar_orig(4), expected(4), fractional_area_new(4)
    real(r8) :: myvar_orig_weighted(4), myvar_weighted(4)

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 7._r8, 8._r8]
    myvar_orig = myvar
    ! If the growing column has a new fractional area of 0, then we expect no change in
    ! my_var.
    expected = myvar

    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new)

    ! Verify
    @assertEqual(expected, myvar, tolerance=tol)
  end subroutine withFractionalAreas_fraction0_oneShrinksOneGrows

  @Test
  subroutine withFractionalAreas_twoShrinkTwoGrow(this)
    ! This tests the updating of a variable with fractional area terms, with one column
    ! shrinking to 0 area, one shrinking to non-zero area, one growing from 0 area, and
    ! one growing from non-zero area
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8,  0._r8,   0.7_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0._r8 , 0.15_r8, 0.08_r8, 0.77_r8]
    real(r8), parameter :: fractional_area_old(4)  = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: new_minus_old(4) = cwtlunit_new - cwtlunit_old
    real(r8) :: mass_gain_per_unit_area
    real(r8) :: myvar(4), myvar_orig(4), expected(4), fractional_area_new(4)
    real(r8) :: myvar_orig_weighted(4), myvar_weighted(4)

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    myvar_orig = myvar
    
    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new)

    ! Verify
    expected(1:2) = myvar_orig(1:2)
    mass_gain_per_unit_area = ( &
         new_minus_old(1) * fractional_area_old(1) * myvar_orig(1) + &
         new_minus_old(2) * fractional_area_old(2) * myvar_orig(2)) / &
         (new_minus_old(1) + new_minus_old(2))
    expected(3) = mass_gain_per_unit_area / fractional_area_new(3)
    expected(4) = (cwtlunit_old(4) * fractional_area_old(4) * myvar_orig(4) + &
         new_minus_old(4) * mass_gain_per_unit_area) / &
         (cwtlunit_new(4) * fractional_area_new(4))
    @assertEqual(expected, myvar, tolerance=tol)

    myvar_orig_weighted = myvar_orig*fractional_area_old
    myvar_weighted = myvar*fractional_area_new
    call this%assertConservation(myvar_orig_weighted, myvar_weighted, 'withFractionalAreas_twoShrinkTwoGrow')
  end subroutine withFractionalAreas_twoShrinkTwoGrow

  @Test
  subroutine nonConservedMass_withFractionalAreas_specialShrinks(this)
    ! This tests the computation of non_conserved_mass with fractional area terms, when
    ! a special column shrinks
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: input_from_special = 11._r8
    real(r8), parameter :: fractional_area_old(3) = [0.1_r8, 0.2_r8, 0.3_r8]
    real(r8) :: fractional_area_new(3)
    real(r8) :: myvar(3), myvar_orig(3)
    real(r8) :: expected_non_conserved_mass
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    real(r8) :: myvar_orig_weighted(3), myvar_weighted(3)

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialShrinks(cs_updater)

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    expected_non_conserved_mass = this%cwtgcell_new_minus_old(3) * fractional_area_old(3) &
         * input_from_special

    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_fill_special_using_fixed_value(bounds, clump_index=1, var=myvar, &
         special_value=input_from_special, non_conserved_mass_grc=non_conserved_mass_grc, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new)

    ! Verify
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)

    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    myvar_orig_weighted = myvar_orig * fractional_area_old
    myvar_weighted = myvar * fractional_area_new
    call this%assertConservation(myvar_orig_weighted, myvar_weighted, &
         'nonConservedMass_withFractionalAreas_specialShrinks', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine nonConservedMass_withFractionalAreas_specialShrinks

  @Test
  subroutine nonConservedMass_withFractionalAreas_specialGrows(this)
    ! This tests the computation of non_conserved_mass with fractional area terms, when
    ! a special column grows
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: input_from_special = 11._r8  ! irrelevant
    real(r8), parameter :: fractional_area_old(3) = [0.1_r8, 0.2_r8, 0.3_r8]
    real(r8) :: fractional_area_new(3)
    real(r8) :: myvar(3), myvar_orig(3)
    real(r8) :: expected_non_conserved_mass
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    real(r8) :: myvar_orig_weighted(3), myvar_weighted(3)

    ! Setup

    call this%do_all_setup_two_veg_and_special_specialGrows(cs_updater)

    myvar = [2._r8, 3._r8, 4._r8]
    myvar_orig = myvar
    expected_non_conserved_mass = -1._r8 * &
         (myvar(1) * this%cwtgcell_new_minus_old(1) * fractional_area_old(1) + &
         myvar(2) * this%cwtgcell_new_minus_old(2) * fractional_area_old(2))

    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_fill_special_using_fixed_value(bounds, clump_index=1, var=myvar, &
         special_value=input_from_special, non_conserved_mass_grc=non_conserved_mass_grc, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new)

    ! Verify
    @assertEqual(expected_non_conserved_mass, non_conserved_mass_grc(1), tolerance=tol)

    ! Note that the specially-treated column is excluded from the conservation check: the
    ! value in that column is ignored for conservation.
    myvar_orig_weighted = myvar_orig * fractional_area_old
    myvar_weighted = myvar * fractional_area_new
    call this%assertConservation(myvar_orig_weighted, myvar_weighted, &
         'nonConservedMass_withFractionalAreas_specialGrows', &
         begc = 1, endc = 2, non_conserved_mass = non_conserved_mass_grc(1))

  end subroutine nonConservedMass_withFractionalAreas_specialGrows

  ! ------------------------------------------------------------------------
  ! Tests of the optional adjustment output
  ! ------------------------------------------------------------------------

  @Test
  subroutine adjustment_withNoAreaChange_isUnchanged(this)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8) :: myvar(4)
    real(r8) :: adjustment(4)
    real(r8) :: adjustment_expected(4)

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8], &
         cwtlunit_new = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8])

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]

    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         adjustment = adjustment)

    adjustment_expected(:) = 0._r8
    @assertEqual(adjustment_expected, adjustment)
  end subroutine adjustment_withNoAreaChange_isUnchanged

  @Test
  subroutine adjustment_withOneShrinksOneGrows(this)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.05_r8, 0.2_r8, 0.35_r8, 0.4_r8]
    real(r8) :: myvar(4), myvar_orig(4)
    real(r8) :: adjustment(4)
    real(r8) :: adjustment_expected(4)

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 4._r8, 5._r8]
    myvar_orig = myvar

    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         adjustment = adjustment)

    adjustment_expected(:) = 0._r8
    adjustment_expected(3) = myvar(3) - myvar_orig(3)
    @assertEqual(adjustment_expected, adjustment)
  end subroutine adjustment_withOneShrinksOneGrows

  @Test
  subroutine adjustment_withSpecialGrowing_isUnchanged(this)
    ! The 'adjustment' variable shouldn't be changed for a special landunit
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8) :: non_conserved_mass_grc(1) = 0._r8
    real(r8) :: myvar(3)
    real(r8) :: adjustment(3)
    real(r8) :: adjustment_expected(3)

    call this%do_all_setup_two_veg_and_special_specialGrows(cs_updater)

    myvar = [2._r8, 3._r8, 4._r8]

    call cs_updater%update_column_state_fill_special_using_natveg(bounds, clump_index=1, var=myvar, &
         non_conserved_mass_grc = non_conserved_mass_grc, adjustment = adjustment)

    adjustment_expected(:) = 0._r8
    @assertEqual(adjustment_expected, adjustment)
  end subroutine adjustment_withSpecialGrowing_isUnchanged

  @Test
  subroutine adjustment_withFractionalAreas(this)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.1_r8, 0.3_r8, 0.2_r8, 0.4_r8]
    real(r8), parameter :: fractional_area_old(4)  = [0.0_r8, 0.1_r8, 0.7_r8, 0.5_r8]
    real(r8) :: myvar(4), myvar_orig(4), fractional_area_new(4)
    real(r8) :: myvar_orig_weighted(4), myvar_weighted(4)
    real(r8) :: adjustment(4)

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 7._r8, 8._r8]
    myvar_orig = myvar
    adjustment(:) = 0._r8

    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new, &
         adjustment = adjustment)

    ! Verify
    myvar_orig_weighted = myvar_orig*fractional_area_old
    myvar_weighted = myvar*fractional_area_new
    @assertEqual(myvar_orig_weighted, myvar_weighted - adjustment)
  end subroutine adjustment_withFractionalAreas

  @Test
  subroutine adjustment_withFractionalAreas_newFrac0(this)
    ! If the new fractional area is 0, then the adjustment should be equal to
    ! -(myvar_orig * fractional_area_old)
    class(TestColumnStateUpdater), intent(inout) :: this
    type(column_state_updater_type) :: cs_updater
    ! col #2 grows from 0, taking over some of col #3; col #2's new fractional area
    ! should be 0 because col #3 had a fractional area of 0
    real(r8), parameter :: cwtlunit_old(4) = [0.1_r8, 0.0_r8, 0.5_r8, 0.4_r8]
    real(r8), parameter :: cwtlunit_new(4) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8]
    real(r8), parameter :: fractional_area_old(4)  = [0.0_r8, 0.1_r8, 0.0_r8, 0.5_r8]
    real(r8) :: myvar(4), myvar_orig(4), fractional_area_new(4)
    real(r8) :: myvar_orig_weighted(4), myvar_weighted(4)
    real(r8) :: adjustment(4)
    real(r8) :: expected_adjustment

    ! Setup

    call this%do_all_setup_with_four_vegetated_columns( &
         cs_updater, &
         cwtlunit_old = cwtlunit_old, &
         cwtlunit_new = cwtlunit_new)

    myvar = [2._r8, 3._r8, 7._r8, 8._r8]
    myvar_orig = myvar
    adjustment(:) = 0._r8

    fractional_area_new(:) = fractional_area_old(:)
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=fractional_area_new)

    ! Exercise
    call cs_updater%update_column_state_no_special_handling(bounds, clump_index=1, var=myvar, &
         fractional_area_old = fractional_area_old, &
         fractional_area_new = fractional_area_new, &
         adjustment = adjustment)

    ! Verify
    expected_adjustment = -1._r8 * (myvar_orig(2) * fractional_area_old(2))
    @assertEqual(expected_adjustment, adjustment(2))
  end subroutine adjustment_withFractionalAreas_newFrac0

end module test_column_state_updater

#!/usr/bin/env perl
#-----------------------------------------------------------------------------------------------
#
# configure
#
#
# This utility allows the CLM user to specify compile-time configuration
# options via a commandline interface.  The output from configure is a
# Makefile and a cache file that contains all configuration parameters
# required to produce the Makefile.  A subsequent invocation of configure
# can use the cache file as input (via the -defaults argument) to reproduce
# the CLM configuration contained in it.  Note that when a cache file is
# used to set default values only the model parameters are used.  The
# parameters that are platform dependent (e.g., compiler options, library
# locations, etc) are ignored.
#
# As the build time configurable options of CLM are changed, this script
# must also be changed.  Thus configure is maintained under revision
# control in the CLM source tree and it is assumed that only the version of
# configure in the source tree will be used to build CLM.  Thus we assume
# that the root of the source tree can be derived from the location of this
# script.
#
#-----------------------------------------------------------------------------------------------

use strict;
#use warnings;
#use diagnostics;

use Cwd;
use English;
use Getopt::Long;
use IO::File;
use IO::Handle;
use File::Copy;

my $crpmode = "nocrop";
my %maxpatchpft;
$maxpatchpft{'crop'}   = 21;
$maxpatchpft{'nocrop'} = 17;
#-----------------------------------------------------------------------------------------------

sub usage {
    die <<EOF;
SYNOPSIS
     configure [options]

     Configure CLM in preparation to be built.
OPTIONS
     User supplied values are denoted in angle brackets (<>).  Any value that contains
     white-space must be quoted.  Long option names may be supplied with either single
     or double leading dashes.  A consequence of this is that single letter options may
     NOT be bundled.

     -bgc <name>            Build CLM with BGC package [ none | cn | cndv ] 
                            (default is none).
     -c13 <name>            Turn on C13 mode for BGC setting of CN [on | off] 
                            (default is off).
     -cache <file>          Name of output cache file (default: config_cache.xml).
     -cachedir <file>       Name of directory where output cache file is written 
                            (default: CLM build directory).
     -clm_root <dir>        Root directory of clm source code 
                            (default: directory above location of this script)
     -cppdefs <string>      A string of user specified CPP defines.  Appended to
                            Makefile defaults.  e.g. -cppdefs '-DVAR1 -DVAR2'
     -crop <name>           Toggle for prognostic crop model. [on | off] (default is off) 
                            (can ONLY be turned on when BGC type is CN or CNDV)
     -comp_intf <name>      Component interface to use (ESMF, MCT or cpl_\$COMP) (default MCT)
     -defaults <file>       Specify full path to a configuration file which will be used 
                            to supply defaults instead of the defaults in bld/config_files.
                            This file is used to specify model configuration parameters only.
                            Parameters relating to the build which are system dependent will
                            be ignored.
     -help [or -h]          Print usage to STDOUT.
     -ninst_lnd <number>    Number of instances (ensembles) of CLM to run (normally 1)
                            Normally used for Data Assimilation
     -nofire                Turn off wildfires for BGC setting of CN 
                            (default includes fire for CN)
     -noio                  Turn history output completely off (typically for testing).
     -pergro <name>         Switch enables building CLM for perturbation growth tests. [on | off] 
                            (default is off)
     -silent [or -s]        Turns on silent mode - only fatal messages issued.
     -sitespf_pt <name>     Setup for the given site specific single-point resolution.
     -snicar_frc <name>     Turn on SNICAR radiative forcing calculation. [on | off] 
                            (default is off)
     -spinup <name>         Turn on given spinup mode for BGC setting of CN		  (level)
                              AD            Turn on Accelerated Decomposition from	      (5)
                                            bare-soil
                              exit          Jump directly from AD spinup to normal mode	      (2)
                              normal        Normal decomposition ("final spinup mode")	      (0)
                                            (default)
                            Valid sequence: 5-2-0
     -target_os             Override the os setting for cross platform compilation 
                            [aix | darwin | linux | solaris | bgl | bgp ].
                            Default: OS on which configure is executing as defined by the 
                            perl \$OSNAME variable.
     -usr_src <dir1>[,<dir2>[,<dir3>[...]]]
                            Directories containing user source code.
     -verbose [or -v]       Turn on verbose echoing of settings made by configure.
     -version               Echo the SVN tag name used to check out this CLM distribution.

OPTIONS used ONLY for clm standalone testing: (i.e. ONLY used when mode=clm_stndln)

    The CESM scripts already take care of everything here. These options exist for
    use with the CLM standalone testing in the models/lnd/clm/test/system directory.

     -mach <name>           Machine name to use
     -mode <name>           CLM mode [clm_stndln | ext_cesm]
     -debug                 Switch to turn on building CLM with debugging compiler options.
     -nc_path <dir>         Path to NetCDF 
                            (lib and include directories should reside beneath it)
     -mct_dir <dir>         Directory to MCT to either build or use pre-built MCT
     -mpi_path <dir>        Path to MPI
                            (lib and include directories should reside beneath it)
     -[no]smp               Switch on [off] SMP parallelism.
     -[no]use_mpiserial     Switch on [off] use of serial-only MPI.
     -pio_dir <dir>         Directory to PIO to either build or use pre-built PIO
     -slibs <options>       Library options to include on the link step (only needed for generic machines)
EOF
}

#-----------------------------------------------------------------------------------------------
# Setting autoflush (an IO::Handle method) on STDOUT helps in debugging.  It forces the test
# descriptions to be printed to STDOUT before the error messages start.

*STDOUT->autoflush();                  

#-----------------------------------------------------------------------------------------------
# Set the directory that contains the CLM configuration scripts.  If the configure command was
# issued using a relative or absolute path, that path is in $ProgDir.  Otherwise assume the
# command was issued from the current working directory.

(my $ProgName = $0) =~ s!(.*)/!!;      # name of this script
my $ProgDir = $1;                      # name of directory containing this script -- may be a
                                       # relative or absolute path, or null if the script is in
                                       # the user's PATH
my $cwd = getcwd();                    # current working directory
my $cfgdir;                            # absolute pathname of directory that contains this script
if ($ProgDir) { 
    $cfgdir = absolute_path($ProgDir);
} else {
    $cfgdir = $cwd;
}

#-----------------------------------------------------------------------------------------------
# Save commandline
my $commandline = "$cfgdir/configure @ARGV";

#-----------------------------------------------------------------------------------------------
# Parse command-line options.
my %opts = (
	    cache       => "config_cache.xml",
            nofire      => undef,
            noio        => undef,
            nc_path     => undef,
            mpi_path    => undef,
            clm_root    => undef,
            spinup      => "normal",
            mct_dir     => undef,
            pio_dir     => undef,
            slibs       => undef,
            ninst_lnd   => 1,
            ninst_atm   => 1,
	    );
GetOptions(
    "c13=s"                     => \$opts{'c13'},
    "spinup=s"                  => \$opts{'spinup'}, 
    "bgc=s"                     => \$opts{'bgc'}, 
    "cache=s"                   => \$opts{'cache'},
    "cachedir=s"                => \$opts{'cachedir'},
    "snicar_frc=s"              => \$opts{'snicar_frc'},
    "clm_root=s"                => \$opts{'clm_root'},
    "cppdefs=s"                 => \$opts{'cppdefs'},
    "comp_intf=s"               => \$opts{'comp_intf'},
    "comp=s"                    => \$opts{'comp'},
    "debug"                     => \$opts{'debug'},
    "defaults=s"                => \$opts{'defaults'},
    "mct_dir=s"                 => \$opts{'mct_dir'},
    "pio_dir=s"                 => \$opts{'pio_dir'},
    "slibs=s"                   => \$opts{'slibs'},
    "mach=s"                    => \$opts{'mach'},
    "h|help"                    => \$opts{'help'},
    "mode=s"                    => \$opts{'mode'},
    "nofire"                    => \$opts{'nofire'},
    "noio"                      => \$opts{'noio'},
    "ninst_lnd=i"               => \$opts{'ninst_lnd'},
    "nc_path=s"                 => \$opts{'nc_path'},
    "mpi_path=s"                => \$opts{'mpi_path'},
    "pergro=s"                  => \$opts{'pergro'}, 
    "snicar_frc=s"              => \$opts{'snicar_frc'}, 
    "s|silent"                  => \$opts{'silent'},
    "smp!"                      => \$opts{'smp'},
    "use_mpiserial!"            => \$opts{'use_mpiserial'},
    "target_os=s"               => \$opts{'target_os'},
    "sitespf_pt=s"              => \$opts{'sitespf_pt'},
    "usr_src=s"                 => \$opts{'usr_src'},
    "v|verbose"                 => \$opts{'verbose'},
    "version"                   => \$opts{'version'},
    "crop=s"                    => \$opts{'crop'}, 
)  or usage();

# Give usage message.
usage() if $opts{'help'};

# Echo version info.
version($cfgdir) if $opts{'version'};    

# Check for unparsed arguments
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}

# Define 3 print levels:
# 0 - only issue fatal error messages
# 1 - only informs what files are created (default)
# 2 - verbose
my $print = 1;
if ($opts{'silent'})  { $print = 0; }
if ($opts{'verbose'}) { $print = 2; }
my $eol = "\n";

my %cfg = ();           # build configuration

#-----------------------------------------------------------------------------------------------
# Make sure we can find required perl modules and configuration files.
# Look for them in the directory that contains the configure script.

# Check for the configuration definition file.
my $config_def_file = "config_definition.xml";
(-f "$cfgdir/config_files/$config_def_file")  or  die <<"EOF";
** Cannot find configuration definition file \"$config_def_file\" in directory 
    \"$cfgdir/config_files\" **
EOF

# The configuration defaults file modifies the generic defaults in the configuration
# definition file.  Note that the -defaults option has precedence over all other options.
my $config_defaults_file;
my $std_config_defaults_file = "$cfgdir/config_files/config_defaults.xml";
if    ($opts{'defaults'})           {
    $config_defaults_file = $opts{'defaults'};
} elsif (defined($opts{'sitespf_pt'})) {
    $config_defaults_file = "$cfgdir/config_files/config_defaults_$opts{'sitespf_pt'}.xml";
    if ( ! -f $config_defaults_file ) {
       $config_defaults_file = "$std_config_defaults_file";
    }
} else {
    $config_defaults_file = "$std_config_defaults_file";
}
(-f "$config_defaults_file")  or  die <<"EOF";
** Cannot find configuration defaults file \"$config_defaults_file\" **
EOF

# System defaults (currently for use_mpiserial, mach, comp and smp settings)
my $sys_defaults_file = 'config_sys_defaults.xml';
(-f "$cfgdir/config_files/$sys_defaults_file")  or  die <<"EOF";
** Cannot find system defaults file \"$sys_defaults_file\" in directory 
    \"$cfgdir/config_fiels\" **
EOF



# The XML::Lite module is required to parse the XML configuration files.
(-f "$cfgdir/../../../../scripts/ccsm_utils/Tools/perl5lib/XML/Lite.pm")  or  die <<"EOF";
** Cannot find perl module \"XML/Lite.pm\" in directory 
    \"$cfgdir/../../../../scripts/ccsm_utils/Tools/perl5lib\" **
EOF

# The Build::Config module provides utilities to store and manipulate the configuration.
(-f "$cfgdir/../../../../scripts/ccsm_utils/Tools/perl5lib/Build/Config.pm")  or  die <<"EOF";
** Cannot find perl module \"Build/Config.pm\" in directory 
    \"$cfgdir/../../../../scripts/ccsm_utils/Tools/perl5lib\" **
EOF

if ($print>=2) { print "Setting CLM configuration script directory to $cfgdir$eol"; }
if ($print>=2) { print "Using configuration defaults file $config_defaults_file$eol"; }

#-----------------------------------------------------------------------------------------------
# Add $cfgdir/perl5lib to the list of paths that Perl searches for modules
my $casecfgdir = "$cfgdir/../../../../scripts/ccsm_utils/Case.template";
my @dirs = (  $cfgdir, "$cfgdir/../../../../scripts/ccsm_utils/Tools/perl5lib","$cfgdir/../../../../scripts/ccsm_utils/Tools", $casecfgdir);
unshift @INC, @dirs;
require XML::Lite;
require Build::Config;

# Initialize the configuration.  The $config_def_file provides the definition of a CLM
# configuration, and the $config_defaults_file provides default values for a specific CLM
# configuration.   $cfg_ref is a reference to the new configuration object.
my $cfg_ref = Build::Config->new("$cfgdir/config_files/$config_def_file", 
				 "$config_defaults_file");

#-----------------------------------------------------------------------------------------------
# Figure out the CLM mode you to run in
if (defined $opts{'mode'}) {
    $cfg_ref->set('mode', $opts{'mode'});
}
my $clm_mode = $cfg_ref->get('mode');
if ($clm_mode ne "clm_stndln" && $clm_mode ne "ext_cesm" ) {
    die <<"EOF";
x** $clm_mode is not a supported mode **
EOF
}
if ($print>=2) { print "Using $clm_mode mode for running clm.$eol"; }

# Note that when building within the CESM or CAM scripts the CLM Makefile is not written
# since the CESM build does not use it.  Many of the checks to ensure that a working
# CLM Makefile is produced are disabled when the cesm option is set.  Use the $clm_build
# variable to turn on CLM specific tests.
my $clm_build = 1;
if ( $clm_mode eq "ext_cesm") {
    $clm_build = 0;
}

#-----------------------------------------------------------------------------------------------
# CLM root directory.  
my $clm_root;

if ( ! defined($opts{'clm_root'} ) ) {
  $clm_root = absolute_path("$cfgdir/..");
} else {
  $clm_root = $opts{'clm_root'};
}

if ( &is_valid_directory( "$clm_root/src", allowEnv=>1 ) ) {
    $cfg_ref->set('clm_root', $clm_root);
} else {
    die <<"EOF";
** Invalid CLM root directory: $clm_root
** 
** The CLM root directory must contain the subdirectory /src/.
** clm_root can be entered on the command line or it will be derived
** from the location of this script.
EOF
}

if ($print>=2) { print "Setting CLM root directory to $clm_root$eol"; }

#-----------------------------------------------------------------------------------------------
# CLM build directory is current directory
my $clm_bld = `pwd`;
chomp( $clm_bld );

# Make sure directory is valid
if ( ! &is_valid_directory( $clm_bld ) and ! mkdirp($clm_bld)) {
    die <<"EOF";
** Could not create the specified CLM build directory: $clm_bld
EOF
}

if ($print>=2) { print "Setting CLM build directory to $clm_bld$eol"; }

#-----------------------------------------------------------------------------------------------
# CLM install directory same as build directory
my $clm_exedir = $clm_bld;

if ($clm_build) {

    if ( ! &is_valid_directory( $clm_exedir ) and ! mkdirp($clm_exedir)) {
	die <<"EOF";
** Could not create the specified CLM installation directory: $clm_exedir
EOF
    }

    if ($print>=2) { print "The CLM executable will be created in $clm_exedir$eol"; }
}

#-----------------------------------------------------------------------------------------------
# User source directories.
my $usr_src = '';
if (defined $opts{'usr_src'}) {
    my @dirs = split ',', $opts{'usr_src'};
    my @adirs;
    while ( my $dir = shift @dirs ) {
	if (&is_valid_directory( "$dir", allowEnv=>1 ) ) {
	    push @adirs, $dir;
	} else {
	    die "** User source directory does not exist: $dir\n";
	}
    }
    $usr_src = join ',', @adirs;
    $cfg_ref->set('usr_src', $usr_src);
}

if ($print>=2) { print "Setting user source directories to $usr_src$eol"; }

#-----------------------------------------------------------------------------------------------
# configuration cache directory and file.
my $config_cache_dir;
my $config_cache_file;
if (defined $opts{'cachedir'}) {
    $config_cache_dir = absolute_path($opts{'cachedir'});
}
else {
    $config_cache_dir = $clm_bld;
}

if (&is_valid_directory( $config_cache_dir, allowEnv=>1 ) or mkdirp($config_cache_dir)) {
    $config_cache_file = "$config_cache_dir/$opts{'cache'}";
} else {
    die <<"EOF";
** Could not create the specified directory for configuration cache file: $config_cache_dir
EOF
}

if ($print>=2) { print "The configuration cache file will be created in $config_cache_file$eol"; }


#-----------------------------------------------------------------------------------------------
# supported single point configurations
if( defined($opts{'sitespf_pt'}) ) {
  $cfg_ref->set('sitespf_pt', $opts{'sitespf_pt'});
}
my $sitespf_pt = $cfg_ref->get('sitespf_pt');
if ($print>=2) { 
   if( defined($opts{'sitespf_pt'}) ) { 
      print "Using $sitespf_pt for supported single point configuration.$eol"; 
   }
}

#-----------------------------------------------------------------------------------------------
# NOIO option
if (defined $opts{'noio'}) {
    $cfg_ref->set('noio', "on" );
}
my $noio = $cfg_ref->get('noio');
if ($print>=2) { 
   if ( $noio eq "on") { print "ALL history output is turned OFF.$eol";       }
}

#-----------------------------------------------------------------------------------------------
# BGC option
if (defined $opts{'bgc'}) {
    $cfg_ref->set('bgc', $opts{'bgc'});
}
my $bgc_mode = $cfg_ref->get('bgc');
if ($print>=2) { print "Using $bgc_mode for bgc.$eol"; }

# NOFIRE option -- currently only in bgc=CN
if (defined $opts{'nofire'}) {
    $cfg_ref->set('nofire', "on" );
}
my $nofire = $cfg_ref->get('nofire');
if ( ($nofire eq "on") && ($bgc_mode ne "cn") ) {
   die <<"EOF";
** Cannot turn nofire mode on -- without cn for bgc mode** 
EOF
}
if ($print>=2 && $bgc_mode =~ /^cn/ ) { 
   if ( $nofire eq "off") { print "Wildfires are active as normal.$eol"; }
   else                   { print "Wildfires are turned off.$eol";       }
}

#-----------------------------------------------------------------------------------------------
# SPINUP option for BGC/CN mode only
if (defined $opts{'spinup'}) {
    $cfg_ref->set('spinup', $opts{'spinup'});
}
my $spinup = $cfg_ref->get('spinup');
if ( ($spinup ne "normal" ) && ($bgc_mode ne "cn") ) {
   die <<"EOF";
** Cannot turn spinup mode on -- without cn for bgc mode** 
** 
** Set the bgc mode by the following means from highest to lowest precedence:
** * by the command-line option -bgc cn
** * by a default configuration file, specified by -defaults 
EOF
}
if ($print>=2) { print "Using $spinup for spinup for cn mode.$eol"; }

# C13 option for BGC/CN mode only
if (defined $opts{'c13'}) {
    $cfg_ref->set('c13', $opts{'c13'});
}
my $c13 = $cfg_ref->get('c13');
if ( ($c13 eq "on" ) && ($bgc_mode ne "cn") ) {
   die <<"EOF";
** Cannot turn c13 mode on -- without cn for bgc mode** 
EOF
}
if ($print>=2) { print "Using $c13 for c13 for cn mode.$eol"; }

#-----------------------------------------------------------------------------------------------
# comp_intf option
if (defined $opts{'comp_intf'}) {
    $cfg_ref->set('comp_intf', $opts{'comp_intf'});
}
my $comp_intf = $cfg_ref->get('comp_intf');
if ($print>=2) { print "Using $comp_intf for comp_intf.$eol"; }

#-----------------------------------------------------------------------------------------------
# ninst_lnd
if (defined $opts{'ninst_lnd'}) {
    if ( $opts{'ninst_lnd'} < 1 || $opts{'ninst_lnd'} > 9999 ) {
        die <<"EOF";
**  The number of ensemble instances of CLM to run is out of the reasonable range of (1-9999)
** 
**** Set the number of ensemble instances of CLM to run with the NINST_LND env_conf variable.
EOF
    }
    $cfg_ref->set('ninst_lnd', $opts{'ninst_lnd'});
}
my $ninst_lnd = $cfg_ref->get('ninst_lnd');
if ($print>=2) { print "Using $ninst_lnd for ninst_lnd.$eol"; }

# ninst_atm
if ($clm_mode eq "clm_stndln" ) {
   if (defined $opts{'ninst_atm'}) {
       if ( $opts{'ninst_atm'} != 1 ) {
          die <<"EOF";
**  The number of ensemble instances of DATM is NOT one
**  Configure and build-namelist are NOT configured for this
** 
EOF
       }
       $cfg_ref->set('ninst_atm', $opts{'ninst_atm'});
    }
    my $ninst_atm = $cfg_ref->get('ninst_atm');
    if ($print>=2) { print "Using $ninst_atm for ninst_atm.$eol"; }
}


#-----------------------------------------------------------------------------------------------
# CROP option
if (defined $opts{'crop'}) {
    $cfg_ref->set('crop', $opts{'crop'});
}
my $crop = $cfg_ref->get('crop');
if ( $crop eq "on" ) {
  $crpmode = "crop";
}
if ( ($crop eq "on" ) && ($bgc_mode ne "cn") && ($bgc_mode ne "cndv") ) {
   die <<"EOF";
** Cannot turn crop mode on -- without some form of cn for bgc mode** 
** 
** Set the bgc mode by the following means from highest to lowest precedence:
** * by the command-line options -bgc cn
** * by a default configuration file, specified by -defaults 
EOF
}
if ( ($c13 eq "on" ) && ($crop eq "on") ) {
   die <<"EOF";
** Cannot turn crop mode on -- AND C13 mode on at the same time**
** 
** Set the crop and C13 modes by the following means from highest to lowest precedence:
** * by the command-line options -crop and -c13
** * by a default configuration file, specified by -defaults 
EOF
}
if ($print>=2) { print "Using $crop for crop.$eol"; }

#-----------------------------------------------------------------------------------------------
# MAXPFT option
$cfg_ref->set('maxpft', $maxpatchpft{$crpmode} );
my $maxpft = $cfg_ref->get('maxpft');
if ( (($bgc_mode eq "cn") || ($bgc_mode eq "cndv")) && ($maxpft != $maxpatchpft{$crpmode}) ) {
   die <<"EOF";
** For CN or CNDV BGC mode you MUST set max patch PFT's to $maxpatchpft{$crpmode}
** 
** When the crop model is on then it must be set to $maxpatchpft{'crop'} otherwise to $maxpatchpft{'nocrop'}
** Set the bgc mode, crop and maxpft by the following means from highest to lowest precedence:
** * by the command-line options -bgc, -crop and -maxpft
** * by a default configuration file, specified by -defaults 
**
EOF
}
if ( $maxpft > $maxpatchpft{$crpmode} ) {
   die <<"EOF";
** Max patch PFT's can NOT exceed $maxpatchpft{$crpmode}
** 
** Set maxpft by the following means from highest to lowest precedence:
** * by the command-line options -maxpft
** * by a default configuration file, specified by -defaults 
**
EOF
}
if ($print>=2) { print "Using $maxpft for maxpft.$eol"; }
#-----------------------------------------------------------------------------------------------
# PERGRO option
if (defined $opts{'pergro'}) {
    $cfg_ref->set('pergro', $opts{'pergro'});
}
my $pergro = $cfg_ref->get('pergro');
if ($print>=2) { print "Using $pergro for pergro.$eol"; }

#-----------------------------------------------------------------------------------------------
# SNICAR_FRC option
if (defined $opts{'snicar_frc'}) {
    $cfg_ref->set('snicar_frc', $opts{'snicar_frc'});
}
my $snicar_frc = $cfg_ref->get('snicar_frc');
if ($print>=2) { print "Using $snicar_frc for snicar_frc.$eol"; }

#-----------------------------------------------------------------------------------------------
# cesm_bld option
if ($clm_mode eq "clm_stndln" ) {
     $cfg_ref->set('cesm_bld', "on" );
} else {
     $cfg_ref->set('cesm_bld', "off" );
}
my $cesm_bld = $cfg_ref->get('cesm_bld');
if ($clm_mode ne "clm_stndln" && $cesm_bld eq "on" ) {
    die <<"EOF";
*** cesm_bld can NOT be turned on if mode does NOT equal clm_stndln **
EOF
}
if ($clm_mode eq "clm_stndln" && $cesm_bld eq "off" ) {
    die <<"EOF";
*** cesm_bld can NOT be turned off if mode equals clm_stndln **
EOF
}
#-----------------------------------------------------------------------------------------------
# Makefile configuration #######################################################################
#-----------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------
# Determine target OS -- allow cross compilation only if target_os is specified on commandline.
my $target_os = $OSNAME;
if (defined $opts{'target_os'}) {
    $target_os = $opts{'target_os'};
}
$cfg_ref->set('target_os', $target_os);

if ($print>=2) { print "Target OS: $target_os.$eol"; }

#-----------------------------------------------------------------------------------------------
# Read system defaults file.
my %sys_defaults = get_sys_defaults("$cfgdir/config_files/$sys_defaults_file", $target_os);

#-----------------------------------------------------------------------------------------------
# Name of CLM executable.
my $clm_exe = "clm";

if ($print>=2) { print "Name of CLM executable: $clm_exe.$eol"; }

#-----------------------------------------------------------------------------------------------
# Use compiler debugging options?
my $debug_opt = (defined $opts{'debug'}) ? 1 : 0;
$cfg_ref->set('debug', $debug_opt);
my $debug = $debug_opt ? 'on': 'off';

if ($print>=2) { print "Compiler debugging options: $debug.$eol"; }

#-----------------------------------------------------------------------------------------------
# USE_MPISERIAL
my $use_mpiserial_val = (defined $opts{'use_mpiserial'}) ? $opts{'use_mpiserial'} : $sys_defaults{'use_mpiserial'};

$cfg_ref->set('use_mpiserial', $use_mpiserial_val);
my $use_mpiserial = $use_mpiserial_val ? 'on': 'off';

if ($print>=2) { print "Use serial-only MPI: $use_mpiserial$eol";}

#-----------------------------------------------------------------------------------------------
# SMP
my $smp_val = (defined $opts{'smp'}) ? $opts{'smp'} : $sys_defaults{'smp'};

$cfg_ref->set('smp', $smp_val);
my $smp = $smp_val ? 'on': 'off';

if ($print>=2) { print "SMP parallelism: $smp$eol";}

#-----------------------------------------------------------------------------------------------
# machine
my $mach_val = (defined $opts{'mach'}) ? $opts{'mach'} : $sys_defaults{'mach'};

$cfg_ref->set('mach', $mach_val);
my $mach = $mach_val;

if ($print>=2) { print "CESM machine: $mach$eol";}

#-----------------------------------------------------------------------------------------------
# compiler
my $comp_val = (defined $opts{'comp'}) ? $opts{'comp'} : $sys_defaults{'comp'};

$cfg_ref->set('comp', $comp_val);
my $comp = $comp_val;

if ($print>=2) { print "CESM compiler: $comp$eol";}

#-----------------------------------------------------------------------------------------------
# PIO and MCT build directories
my($mct_dir,$pio_dir,$sub_dir);
if ($clm_mode eq "clm_stndln" ) {
   # subdirectory for both
   if ( $debug eq "on" ) {
      $sub_dir .= "/debug"
   } else {
      $sub_dir .= "/opt"
   }
   if ( $use_mpiserial eq "on" ) {
      $sub_dir .= "-mpiserial"
   } else {
      $sub_dir .= "-mpi"
   }
   if ( $smp eq "on" ) {
      $sub_dir .= "-smp"
   } else {
      $sub_dir .= "-nosmp"
   }
   # MCT
   if (defined $opts{'mct_dir'}){
       $mct_dir = $opts{'mct_dir'};
   }else{
       $mct_dir = "$clm_bld/mct";
   }
   $mct_dir .= $sub_dir;
   $cfg_ref->set('mct_dir', $mct_dir);
   if ($print>=2) { print "Build MCT library $mct_dir $eol"; }
   
   # PIO
   if (defined $opts{'pio_dir'}){
       $pio_dir = $opts{'pio_dir'};
   }else{
       $pio_dir = "$clm_bld/pio";
   }
   $pio_dir .= $sub_dir;
   $cfg_ref->set('pio_dir', $pio_dir);
   if ($print>=2) { print "Build PIO library $pio_dir $eol"; }
}
#-----------------------------------------------------------------------------------------------
# For the CPP tokens, start with the defaults (from defaults file) and append the specifications
# from the commandline.  That way the user can override defaults since the commandline versions
# occur last.
my $usr_cppdefs = $cfg_ref->get('cppdefs');
if (defined $opts{'cppdefs'}) {
    $usr_cppdefs .= " $opts{'cppdefs'}";
}
$cfg_ref->set('cppdefs', $usr_cppdefs);

if ($usr_cppdefs and $print>=2) { print "Default and user CPP definitions: \'$usr_cppdefs\'$eol";}

# The following CPP macro definitions are used to implement the compile-time options.  They are
# determined by the configuration parameters that have been set above.  They will be appended to
# the CPP definitions that were explicitly set in the defaults file or by the user on the commandline.
my $cfg_cppdefs = '';

# Fortran name mangling (only when NOT using the CESM build as it already does this)
if ( $clm_mode ne "ext_cesm" && $cesm_bld ne "on" ) {
   if ( $target_os eq 'aix'  or  $target_os eq 'darwin'  
   or   $target_os eq 'bgl'  or  $target_os eq 'bgp' ) {
       $cfg_cppdefs .= " -DFORTRAN_SAME";
   }
   elsif ( $target_os eq 'irix'      or  $target_os eq 'linux'   or
           $target_os eq 'super-us'  or  $target_os eq 'es'      or
           $target_os eq 'solaris'   or  $target_os eq 'dec_osf'   ) {
       $cfg_cppdefs .= " -DFORTRANUNDERSCORE";
   }
}

$cfg_cppdefs .= " -DMAXPATCH_PFT=$maxpft";

if ($bgc_mode eq 'cn') { 
    $cfg_cppdefs .= " -DCN";
}
if ($crop eq 'on') { 
    $cfg_cppdefs .= " -DCROP";
}
if ($bgc_mode eq 'cndv') { 
    $cfg_cppdefs .= " -DCNDV -DCN";
}
if ($nofire eq 'on') {
    $cfg_cppdefs .= " -DNOFIRE";
}
if ($noio eq 'on') {
    $cfg_cppdefs .= " -D_NOIO";
}
if ($c13 eq 'on') { 
    $cfg_cppdefs .= " -DC13";
}
if ($spinup eq 'AD') { 
    $cfg_cppdefs .= " -DAD_SPINUP";
}
if ($spinup eq 'exit') { 
    $cfg_cppdefs .= " -DEXIT_SPINUP";
}
if ( $pergro eq 'on' ) {
    $cfg_cppdefs .= " -DPERGRO";
}
if ( $snicar_frc eq 'on' ) {
    $cfg_cppdefs .= " -DSNICAR_FRC";
}
# Always build with PIO
$cfg_cppdefs .= " -D_USEBOX -D_NETCDF";
if ( ($clm_mode eq "clm_stndln") && ($use_mpiserial eq "on") ) { $cfg_cppdefs .= " -D_MPISERIAL";}
if ( $clm_mode eq "clm_stndln" ) {
   my $NINST_LND = $cfg_ref->get( "ninst_lnd" );
   my $NINST_ATM = $cfg_ref->get( "ninst_atm" );
   $cfg_cppdefs .= " -DNUM_COMP_INST_ATM=$NINST_ATM" .
                   " -DNUM_COMP_INST_LND=$NINST_LND" .
    	           " -DNUM_COMP_INST_OCN=1" .
                   " -DNUM_COMP_INST_ICE=1" .
		   " -DNUM_COMP_INST_GLC=1";
}

# CPP defines to put on Makefile
my $make_cppdefs = "$usr_cppdefs $cfg_cppdefs";

if ($print>=2) { print "CPP definitions set by configure: \'$cfg_cppdefs\'$eol"; }

#-----------------------------------------------------------------------------------------------
# External libraries ###########################################################################
#-----------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------
# NetCDF path
my $nc_path = '';
if ($clm_build) {
    if (defined $opts{'nc_path'}) {
	$nc_path = $opts{'nc_path'};
    }
    elsif (defined $ENV{NETCDF_PATH}) {
        print "nc_path set to NETCDF_PATH env variable\n" if $print>0;
	$nc_path = $ENV{NETCDF_PATH};
    }
    else {
	$nc_path = '/usr/local';
    }

    my $nc_inc = "$nc_path/include";

    if (-f "$nc_inc/netcdf.inc") {
	$cfg_ref->set('nc_path', $nc_path);
    }
    else {
	die <<"EOF";
** Cannot find netcdf.inc in specified directory: $nc_inc
** 
** The NetCDF include directory is determined from the following set of options listed
** from highest to lowest precedence:
** * by the command-line option -nc_path
** * by the environment variable NETCDF_PATH
** * by the default value /usr/local
EOF
    }

    if ($print>=2) { print "Found netCDF include file in $nc_inc$eol"; }
}

# NetCDF library
if ($clm_build) {
    my $nc_lib = "$nc_path/lib";

    if ( ! -f "$nc_lib/libnetcdf.a") {
	die <<"EOF";
** Cannot find libnetcdf.a in specified directory: $nc_lib
** 
** The NetCDF library directory is determined from the following set of options listed
** from highest to lowest precedence:
** * by the command-line option -nc_path
** * by the environment variable NETCDF_PATH
** * by the default value /usr/local
EOF
    }

    if ($print>=2) { print "Found netCDF library in $nc_lib$eol"; }
}

# NetCDF module files
if ($clm_build) {
    my $nc_mod = "$nc_path/include";
    my $nc_lib = "$nc_path/lib";

    # check for the mod files in the user specified location
    if ($nc_mod and (-f "$nc_mod/netcdf.mod"    or -f "$nc_mod/NETCDF.mod")
                and (-f "$nc_mod/typesizes.mod" or -f "$nc_mod/TYPESIZES.mod") ) {
    }
    # if not there check in the netcdf lib directory
    elsif (    (-f "$nc_lib/netcdf.mod"    or -f "$nc_lib/NETCDF.mod")
           and (-f "$nc_lib/typesizes.mod" or -f "$nc_lib/TYPESIZES.mod") ) { 
         $nc_mod = $nc_lib;
    } 
    else {
	die <<"EOF";
** Cannot find netcdf.mod and typesizes.mod in specified directories: 
**  $nc_mod
**  $nc_lib
** 
** The NetCDF module directory is determined from the following set of options listed
** from highest to lowest precedence:
** * by the command-line option -nc_path
** * by the environment variable NETCDF_PATH
** * by the directories containing the NetCDF library or include files
EOF
   }

    if ($print>=2) { print "Found netCDF module files in $nc_mod$eol"; }
}

#-----------------------------------------------------------------------------------------------
# MPI
# Only check for the MPI include or library files if the user has explicitly specified
# where to look.  Often the Fortran compiler knows where to look for these files and so
# not specifying them is the best strategy.
my $mpi_path = '';
if ($clm_build and $use_mpiserial eq 'off') {

    my $mpi_lib = '';
    my $mpi_inc = '';
    # MPI include
    if (defined $opts{'mpi_path'}) {
	$mpi_path = $opts{'mpi_path'};
    }
    elsif (defined $ENV{MPICH_PATH}) {
        print "mpi_path set to MPICH_PATH env variable\n" if $print>0;
	$mpi_path = $ENV{MPICH_PATH};
    }
    $mpi_inc = "$mpi_path/include";

    if ($mpi_path eq '' or -f "$mpi_inc/mpif.h") {
	$cfg_ref->set('mpi_path', $mpi_path);
    }
    else {
	die <<"EOF";
** Cannot find mpif.h in specified directory: $mpi_inc
** 
** The MPI include directory is determined from the following set of options listed
** from highest to lowest precedence:
** * by the command-line option -mpi_path
** * by the environment variable MPICH_PATH
EOF
    }

    if ($mpi_inc and $print>=2) { print "Found MPI include file in $mpi_inc$eol"; }

    # MPI library
    $mpi_lib = "$mpi_path/lib";

    if ($mpi_path eq '') {
    }
    elsif (-f "$mpi_lib/libmpi.a" or -f "$mpi_lib/libmpi.so") {
    }
    elsif (-f "$mpi_lib/libmpich.a") {
    }
    else {
	die <<"EOF";
** Cannot find libmpi.a, libmpi.so or libmpich.a in specified directory: $mpi_lib
** 
** The MPI library directory is determined from the following set of options listed
** from highest to lowest precedence:
** * by the command-line option -mpi_path
** * by the environment variable MPICH_PATH
EOF
    }

    if ($mpi_lib and $print>=2) { print "Found MPI library in $mpi_lib$eol"; }

}

#-----------------------------------------------------------------------------------------------
# Write configuration files ####################################################################
#-----------------------------------------------------------------------------------------------

my $fp_filename      = 'Filepath';             # name of output filepath file
my $cpp_filename     = 'CESM_cppdefs';         # name of output file for clm's cppdefs in cesm

if ($clm_mode eq "ext_cesm" ) {

    # Write the filepath file for cesm.
    write_filepath_cesmbld("$clm_bld/$fp_filename", "clm", $cfg_ref, allowEnv=>1 );
    if ($print>=2) { print "creating $clm_bld/$fp_filename\n"; }

    # Write the file for clm's cppdefs needed in cesm.
    write_cppdefs("$clm_bld/$cpp_filename", $make_cppdefs);
    if ($print>=2) { print "creating $clm_bld/$cpp_filename\n"; }

} elsif ( $cesm_bld eq "on" ) {

    # The ConfigCase module provides utilities to store and manipulate the configuration.
    (-f "$casecfgdir/ConfigCase.pm")  or  die <<"EOF";
** Cannot find perl module \"ConfigCase.pm\" in directory 
  \"$casecfgdir\" **
EOF
    # The SetupTools module provides utilities to store and manipulate the configuration.
    (-f "$cfgdir/../../../../scripts/ccsm_utils/Tools/SetupTools.pm")  or  die <<"EOF";
** Cannot find perl module \"SetupTools.pm\" in directory 
  \"$casecfgdir\" **
EOF
    require ConfigCase;
    require SetupTools;

    my $macro      = "Macros";
    my $envset     = "Macros.env_conf-build";
    my $config_dir = "$cfgdir/config_files";
    my $scriptsdir = "$cfgdir/../../../../scripts/ccsm_utils/Machines";
    my $builddir   = "$scriptsdir";

    # Create all the directories and subdirectories needed
    my @dirs = ( "$clm_bld",                    "$clm_bld/lib", "$clm_bld/include", 
                 "$clm_bld/SourceMods/src.clm", "$clm_bld/SourceMods/src.cesm",
                 "$clm_bld/cesm_lib",           "$clm_bld/lnd" );
    foreach my $dir ( @dirs ) {
       mkdirp( "$dir" );
    }

    # Create and build MCT and PIO
    if(-d $mct_dir){
       print "Using existing mct_dir: $mct_dir\n";
    }else{
       print "creating $mct_dir\n" if($print);
       my $mct_root = "$clm_root/../../utils/mct";
       mkdirp($mct_dir);
       mkdir("$mct_dir/mct");
       mkdir("$mct_dir/mpeu");
       mkdir("$mct_dir/mpi-serial");
       copy("$mct_root/Makefile",$mct_dir);
       copy("$mct_root/mct/Makefile","$mct_dir/mct");
       copy("$mct_root/mpeu/Makefile","$mct_dir/mpeu");
       copy("$mct_root/mpi-serial/Makefile","$mct_dir/mpi-serial");
    } 

    # PIO library
    #
    # add include to build pio
    my $bfFixInclude="-I${clm_bld}/../mct/opt-mpiserial-nosmp/mpi-serial -I${clm_bld}/cesm_lib";
    if(-d $pio_dir){
       print "Using existing pio_dir: $pio_dir\n";
    }else{
      my $pio_root= "$clm_root/../../utils/pio";
      print "creating $pio_dir\n" if($print);
      mkdirp($pio_dir);
      copy("$pio_root/Makefile","$pio_dir/Makefile");

      rename ("$pio_dir/Makefile","$pio_dir/Makefile.orig" ) || die ( "Error in renaming" );

      my $fh_in = IO::File->new("$pio_dir/Makefile.orig", '<') or die "** can't open pio Makefile\n";
      my $fh_out = IO::File->new("$pio_dir/Makefile", '>') or die "** can't open pio Makefile\n";

      # fix missing include
      while (<$fh_in>) {
        if ($_ =~ /export PIOARCH/ ){
           print $fh_out $_;
           my $nextline = <$fh_in> ;
           $fh_out->print("\n FFLAGS+= $bfFixInclude\n\n");
         } else { 
           print $fh_out $_;
         }
      }
      # fix dep on pio_kinds.o
      $fh_out->print("piovdc.o: pio_kinds.o \n");

      $fh_in->close;
      $fh_out->close;
      # clean up
      unlink("$pio_dir/Makefile.orig");

    }

    # Write the file for clm's cppdefs needed in cesm.
    write_cppdefs("$clm_bld/$cpp_filename", $make_cppdefs);
    if ($print>=2) { print "creating $clm_bld/$cpp_filename\n"; }

    # Machines definition file.
    my $machine_file = 'config_machines.xml';
    (-f "$scriptsdir/$machine_file")  or  die <<"EOF";
** Cannot find machine parameters file \"$machine_file\" in directory 
    \"$scriptsdir\" **
EOF

    # Compiler definition file.
    my $compiler_file = 'config_compilers.xml';
    (-f "$scriptsdir/$compiler_file")  or  die <<"EOF";
** Cannot find compiler parameters file \"$compiler_file\" in directory 
    \"$scriptsdir\" **
EOF

    # Create new config object
    my $cfgcas_ref = ConfigCase->new("$casecfgdir/$config_def_file");

    if($mach =~ /generic_(.*)/){
      $cfgcas_ref->set('OS',$1);
      $cfgcas_ref->set('MACH','generic');
      if ( defined($opts{'slibs'}) ) {
         $cfg_ref->set('slibs',$opts{'slibs'});
      } elsif ( $ENV{'SLIBS'} ne "" ) {
         $cfg_ref->set('slibs',$ENV{'SLIBS'} );
         print "slibs set to SLIBS env variable\n" if $print>0;
      }
    }else{
      $cfgcas_ref->set_machine("$scriptsdir/$machine_file", $mach, $print);
      if ( defined($opts{'slibs'}) ) {
	die <<"EOF";
** Do NOT define slibs option for a NON generic machine
** 
EOF
      }
      $cfg_ref->set('slibs',"");
    }

    # Write the Macro's file for machine dependent build information
    SetupTools->set_compiler("$scriptsdir/$compiler_file",$comp, $mach, $print, "$scriptsdir/$macro");
    write_envset("$clm_bld/$envset", $cfg_ref, $cfgcas_ref );
    write_macros("$scriptsdir/$macro", "$clm_bld/$macro" );
    if ($print>=2) { print "creating $clm_bld/$macro\n"; }

    # Write the cesm top level Makefile.
    write_cesm_makefile("$scriptsdir/Makefile", "$clm_bld/Makefile",
                        "$clm_bld/$envset", "driver", "$macro", $cfg_ref,$bfFixInclude );
    if ($print>=2) { print "creating $clm_bld/cesm_lib/Makefile\n"; }

    # Write the top level filepath file for cesm build
    write_filepath_cesmbld("$clm_bld/$fp_filename", "driver", $cfg_ref);
    if ($print>=2) { print "creating $clm_bld/$fp_filename\n"; }

    # Write the cesm_lib level Makefile.
    write_cesm_makefile("$scriptsdir/Makefile", "$clm_bld/cesm_lib/Makefile", 
                        "$clm_bld/$envset", "cesm_lib", "../$macro", $cfg_ref,$bfFixInclude );
    if ($print>=2) { print "creating $clm_bld/cesm_lib/Makefile\n"; }

    # Write the cesm_lib level filepath file for cesm build
    write_filepath_cesmbld("$clm_bld/cesm_lib/$fp_filename", "cesm_lib", $cfg_ref);
    if ($print>=2) { print "creating $clm_bld/cesm_lib/$fp_filename\n"; }

    # Write the lnd level Makefile.
    write_cesm_makefile("$scriptsdir/Makefile", "$clm_bld/lnd/Makefile", 
                        "$clm_bld/$envset", "clm", "../$macro", $cfg_ref,$bfFixInclude );
    if ($print>=2) { print "creating $clm_bld/lnd/Makefile\n"; }

    # Write the filepath file for cesm build of clm library
    write_filepath_cesmbld("$clm_bld/lnd/$fp_filename", "clm", $cfg_ref);
    if ($print>=2) { print "creating $clm_bld/lnd/$fp_filename\n"; }


} else {
	die <<"EOF";
** Mode and cesm_bld option are not valid.
** 
EOF

}


# Write the configuration file.
$cfg_ref->write_file($config_cache_file, $commandline);
if ($print>=2) { print "creating $config_cache_file\n"; }

#-----------------------------------------------------------------------------------------------
# Done
chdir( $cwd ) || die <<"EOF";
** Trouble changing directory back to $cwd
**
EOF
if ($print) { print "CLM configure done.\n"; }
exit;

#-----------------------------------------------------------------------------------------------
# FINISHED ####################################################################################
#-----------------------------------------------------------------------------------------------

#-------------------------------------------------------------------------------

sub write_filepath_cesmbld
{
    my ($file, $model, $cfg_ref, %opts) = @_;
    my  $fh = new IO::File;

    $fh->open(">$file") or die "** can't open filepath file: $file\n";

    # configuration parameters used to determine paths
    my $usr_src       = $cfg_ref->get('usr_src');
    my $clm_root      = $cfg_ref->get('clm_root');
    my $use_mpiserial = $cfg_ref->get('use_mpiserial');
    my $mode          = $cfg_ref->get('mode');
    my $comp_intf     = $cfg_ref->get('comp_intf');

    # Source root
    my $srcdir = "$clm_root/src";
    if ( ! &is_valid_directory( "$srcdir", %opts )  ) { die "** source directory does not exist: $srcdir\n"; }

    # Shared utilities.
    if ( $model eq "cesm_lib" ) {
       my @dirs = ( "csm_share/shr", 
                    "utils/timing",   
                  );
       push( @dirs, "utils/esmf_wrf_timemgr" );

       print $fh "../SourceMods/src.cesm\n";

       foreach my $dir ( @dirs ) {
	   if ( &is_valid_directory( "$srcdir/$dir", %opts )  ) {
	       print $fh "$srcdir/$dir\n";
	   } elsif ( &is_valid_directory( "$srcdir/../../../$dir", %opts )  ) {
	       print $fh absolute_path( "$srcdir/../../../$dir" ) . "\n";
	   } else {
	       die "** source directory does not exist: $srcdir/$dir or $srcdir/../../../$dir\n";
	   }
       }
    
       # Driver, stub ocean, stub glacier, and stub sea-ice
       if ($mode eq "clm_stndln") {
	   my @dirs = ( "drv/shr", "atm/datm", "ocn/socn", "ice/sice", "glc/sglc" );
           if ( $comp_intf eq "MCT" ) { 
	       push( @dirs, "atm/datm/cpl_mct" );
	       #push( @dirs, "drv/shr_mct" );
           } elsif ( $comp_intf eq "ESMF" ) { 
	       push( @dirs, "atm/datm/cpl_esmf" );
	       push( @dirs, "drv/shr_esmf" );
           } else {
	       push( @dirs, "main/$comp_intf" );
           }
	   foreach my $dir ( @dirs ) {
               # For stub components
               if ( $dir =~ /^...\/s...$/ ) {
                  if ( $comp_intf eq "MCT" ) { 
                     $dir .= "/cpl_mct";
                  } elsif ( $comp_intf eq "ESMF" ) { 
                     $dir .= "/cpl_esmf";
                 } else {
                     $dir .= "/$comp_intf";
                  }
               }
	       if ( &is_valid_directory( "$srcdir/../../../$dir", %opts )  ) {
		   print $fh absolute_path( "$srcdir/../../../$dir" ) . "\n";
	       } else {
		   die "** source directory does not exist: $srcdir/../../../$dir\n";
	       }
	   }
       }
    }
    
    # CLM
    if ( $model eq "clm" ) {

       # User specified source directories.
       if ($usr_src  =~ /\S+/) {
	   my @dirs = split ',', $usr_src;
	   while ( my $dir = shift @dirs ) {
	       print $fh "$dir\n";
           }
       } else {
          print $fh "../SourceMods/src.clm\n";
       }

       my @dirs = ( "cpl_share", "main", "biogeophys", "biogeochem");
       if ( $comp_intf eq "MCT" ) { 
	   push( @dirs, "cpl_mct" );
       } elsif ( $comp_intf eq "ESMF" ) { 
	   push( @dirs, "cpl_esmf" );
       } else {
	   push( @dirs, "$comp_intf" );
       }
       foreach my $dir ( @dirs ) {
	   if ( &is_valid_directory( "$srcdir/$dir", %opts )  ) {
	       print $fh "$srcdir/$dir\n";
	   } else {
	       die "** source directory does not exist: $srcdir/$dir\n";
	   }
       }
    }

    # CESM driver
    if ( $model eq "driver" ) {
       print $fh absolute_path( "$srcdir/../../../drv/driver" ) . "\n";
    }
    
    $fh->close;
}
#-------------------------------------------------------------------------------

sub write_cppdefs
{
    my ($file, $make_cppdefs) = @_;
    my  $fh = new IO::File;

    $fh->open(">$file") or die "** can't open cpp defs file: $file\n";

    print $fh "$make_cppdefs\n";
    $fh->close;
}

#-------------------------------------------------------------------------------

sub write_envset
{
    my ($envset, $cfg_ref, $cfgcas_ref) = @_;

    # configuration parameters
    my $nc_path       = $cfg_ref->get('nc_path');
    my $debug         = $cfg_ref->get('debug') ? 'TRUE' : 'FALSE';
    my $os            = $cfgcas_ref->get('OS');
    my $mpilibs       = $cfgcas_ref->get('MPILIBS');
    my @mpilibs       = split ",", $mpilibs, -1;
    my $mpilib        = $cfg_ref->get('use_mpiserial') ? 'mpi-serial' : $mpilibs[0];
    my $smp           = $cfg_ref->get('smp') ? 'TRUE' : 'FALSE';
    my $clm_root      = $cfg_ref->get('clm_root');
    my $compiler      = $cfg_ref->get('comp');
    my $compile_threaded = "false";
    if ( $smp eq "TRUE" ) {
       $compile_threaded = "true";
    }

    my $casetools = absolute_path( "$clm_root/../../../scripts/ccsm_utils/Machines" );
    my $coderoot  = absolute_path( "$clm_root/../../../models" );

    my $mpi_path     = $cfg_ref->get('mpi_path');
    my $mct_libdir   = $cfg_ref->get('mct_dir');
    my $pio_libdir   = $cfg_ref->get('pio_dir');
    my $slibs        = $cfg_ref->get('slibs');

    my  $fh_out = new IO::File;

    $fh_out->open(">$envset") or die "** can't open env_settings file: $envset\n";
    print $fh_out  <<"EOF";
# env_conf and env_build settings for building CLM using the CESM build files.
BLDROOT                 := $clm_bld
CASEROOT                := $clm_bld
CASETOOLS               := $casetools
CODEROOT                := $coderoot
LIBROOT                 := \$(BLDROOT)/lib
INCROOT                 := \$(BLDROOT)/include
SMP                     := $smp
compile_threaded        := $compile_threaded
DEBUG                   := $debug
BUILD_THREADED          := $smp
FRAMEWORK               := MCT
USER_CPPDEFS            := \$(shell cat \$(BLDROOT)/CESM_cppdefs)
NETCDF_DIR              := $nc_path
MPICH_PATH              := $mpi_path
MPILIBS                 := $mpilibs
MPILIB                  := $mpilib
COMPILER                := $comp
OS                      := $os
USE_ESMF_LIB            := FALSE
MCT_LIBDIR              := $mct_libdir
PIO_LIBDIR              := $pio_libdir
EOF
    if ( $slibs ne "" ) {
       print $fh_out  <<"EOF";
SLIBS                   := $slibs
EOF
    }
    $fh_out->close;
}

#-------------------------------------------------------------------------------

sub write_macros
{
    my ($file_in, $file_out) = @_;
    my  $fh_in  = new IO::File;
    my  $fh_out = new IO::File;

    $fh_in->open("<$file_in") or die "** can't open macros file: $file_in\n";
    $fh_out->open(">$file_out") or die "** can't open macros file: $file_out\n";

    # Copy the "template" cpp Macros file to the new file.
    $fh_in->open("<$file_in") or die "** can't open file: $file_in\n";
    while (<$fh_in>) {
      print $fh_out $_;
    }
    $fh_in->close;
    $fh_out->close;
}

#-------------------------------------------------------------------------------

sub write_cesm_makefile
{
    # Add macro definitions to the beginning of the cesm Makefile that will be written

    my ($file_in, $file_out, $envset, $model, $macfile, $cfg_ref, $bfFixInclude) = @_;
    my  $fh_in = new IO::File;
    my  $fh_out = new IO::File;

    $fh_out->open(">$file_out") or die "** can't open file: $file_out\n";

    # configuration parameters

    my $target_name;
    my $target;
    my $lib_name;
    if ( $model eq "driver" ) {
       $target_name = "EXEC_SE := $clm_exedir/$clm_exe";
       $target      = "exec_se";
    } else {
       if ( $model eq "clm" ) {
          $lib_name = "lnd";
       } else { 
          $lib_name = "$model";
       }
       $target_name = "COMPLIB := \$(LIBROOT)/lib$lib_name.a";
       $target      = "mkcomplib";
    }
    print $fh_out  <<"EOF";
# env conf and build settings for CLM.
MODEL   := $model
ENVFILE := $envset
-include \$(ENVFILE)
$target_name

target: $target

EOF
    if ( $model eq "driver" ) {
        if ( $macfile !~ /darwin_intel/ ) {
           print $fh_out  <<"EOF";
ULIBS        := -L\$(LIBROOT) -lcesm_lib
CLIBS        := -L\$(LIBROOT) -llnd
EOF
        } else {
           print $fh_out  <<"EOF";
ULIBS   := -all_load \$(LIBROOT)/libcesm_lib.a
CLIBS   := -all_load \$(LIBROOT)/liblnd.a
EOF
        }
        print $fh_out  <<"EOF";
ULIBDEP := \$(LIBROOT)/libcesm_lib.a \$(LIBROOT)/liblnd.a

\$(LIBROOT)/liblnd.a: \$(LIBROOT)/libcesm_lib.a
	\$(MAKE) -C lnd  mkcomplib

\$(LIBROOT)/libcesm_lib.a:  \$(MCTLIBS) \$(PIOLIB) 
	\$(MAKE) -C cesm_lib mkcomplib

#-----------------------------------------------------------------------------
# This is duplicated from the CESM Makefile with the following mods.
# The changes are highlighted with "### NOTE:" and are as follows...
#
# 1.) Include dependency on $(ULIBDEP) for Depends file
# 2.) On clean go to subdirectories and clean
#-----------------------------------------------------------------------------

EOF

    } else {
        print $fh_out  <<"EOF";

mkcomplib: complib copymod
copymod: complib
	\$(CP) *.mod \$(INCROOT)
EOF
    }

    my $bfFixComp;
    my $bfFixCPP;
    if ($target_os eq "aix"){
      $bfFixComp="-WF,-DFORTRAN_SAME -WF,-DAIX -WF,-DCPRIBM -WF,-DF2003";
      $bfFixCPP="-WF,-DNO_MPI2 -WF,-DNO_MPIMOD -WF,-D_USEBOX -WF,-D_NETCDF -WF,-D_MPISERIAL -WF,-DNUM_COMP_INST_ATM=1 -WF,-DNUM_COMP_INST_LND=1 -WF,-DNUM_COMP_INST_OCN=1 -WF,-DNUM_COMP_INST_ICE=1 -WF,-DNUM_COMP_INST_GLC=1";
    } elsif ($target_os eq "linux"){
      $bfFixComp="-DFORTRANUNDERSCORE -DF2003";
      $bfFixCPP="-DNO_MPI2 -DNO_MPIMOD -D_USEBOX -D_NETCDF -D_MPISERIAL -DNUM_COMP_INST_ATM=1 -DNUM_COMP_INST_LND=1 -DNUM_COMP_INST_OCN=1 -DNUM_COMP_INST_ICE=1 -DNUM_COMP_INST_GLC=1";
    }
    # Copy the "template" makefile to the new makefile.
    $fh_in->open("<$file_in") or die "** can't open file: $file_in\n";
    while (<$fh_in>) {
        # Remove -lgptl from Makefile.  the GPTL objects are in libcesm_lib.a but newer CESM code builds gptl in 
        # it's own directory.  Since we don't have access to gnu sed copy to a tmp file.
        my $word="-lgptl";
        if ($_ =~ /$word/ ){
           chomp( $_ );
           my $ri = rindex($_,$word);
           substr($_,$ri,length($word)) = '' if $ri > -1;
        } elsif ($_ =~ /FFLAGS\+=\$\(FPPDEFS\)/  ){
           # add includes and some definitions that aren't being picked up
           chomp( $_ );
           $_ = "$_ $bfFixComp $bfFixInclude $bfFixCPP \n";
        }
        if ( $model eq "driver" ) {
           # Add ULIBDEP to end of Depends dependency
           if ($_ =~ /\$\(CURDIR\)\/Depends\:/ ) {
              chomp( $_ );
              $_ = "$_ \$(ULIBDEP)\n";
           }
        }
        print $fh_out $_;
        if ( $model eq "driver" ) {
          if ( /(mostly|real||)clean\:\s*$/ ) {
             my $type = $1;
             $_ = <$fh_in>;
             print $fh_out $_;
             print $fh_out "### NOTE: Also remove these and then go to subdirs...\n";
             if ( $type eq "real" && $type eq "" ) {
                print $fh_out "\t\$(RM) -f \$(INCROOT)/* \$(LIBROOT)/*\n";
             }
             print $fh_out "\tcd lnd;      \$(MAKE) \$@\n";
             print $fh_out "\tcd cesm_lib; \$(MAKE) \$@\n";
          }
        }
    }

    $fh_out->close;
    $fh_in->close;
}

#-------------------------------------------------------------------------------

sub get_sys_defaults
{
    my ($file, $os) = @_;
    my $xml = XML::Lite->new( $file );
    my $root = $xml->root_element();
    my $e;          # xml element
    my %a;          # element attributes
    my %sys = ();   # return values

    # Check for valid root node
    my $name = $root->get_name();
    $name eq "system_defaults" or die
	"file $file is not a system defaults file\n";

    my @vars = ( "use_mpiserial", "smp", "mach", "comp" );
    foreach my $var ( @vars ) {
       $e = $xml->elements_by_name( $var );
       %a = $e->get_attributes();
       $sys{$var} = $a{$os};
    }

    return %sys;
}

#-------------------------------------------------------------------------------

sub absolute_path {
#
# Convert a pathname into an absolute pathname, expanding any . or .. characters.
# Assumes pathnames refer to a local filesystem.
# Assumes the directory separator is "/".
#
  my $path = shift;
  my $cwd = getcwd();  # current working directory
  my $abspath;         # resulting absolute pathname

# Strip off any leading or trailing whitespace.  (This pattern won't match if
# there's embedded whitespace.
  $path =~ s!^\s*(\S*)\s*$!$1!;

# Convert relative to absolute path.

  if ($path =~ m!^\.$!) {          # path is "."
      return $cwd;
  } elsif ($path =~ m!^\./!) {     # path starts with "./"
      $path =~ s!^\.!$cwd!;
  } elsif ($path =~ m!^\.\.$!) {   # path is ".."
      $path = "$cwd/..";
  } elsif ($path =~ m!^\.\./!) {   # path starts with "../"
      $path = "$cwd/$path";
  } elsif ($path =~ m!^[^/]!) {    # path starts with non-slash character
      $path = "$cwd/$path";
  }

  my ($dir, @dirs2);
  my @dirs = split "/", $path, -1;   # The -1 prevents split from stripping trailing nulls
                                     # This enables correct processing of the input "/".

  # Remove any "" that are not leading.
  for (my $i=0; $i<=$#dirs; ++$i) {
      if ($i == 0 or $dirs[$i] ne "") {
	  push @dirs2, $dirs[$i];
      }
  }
  @dirs = ();

  # Remove any "."
  foreach $dir (@dirs2) {
      unless ($dir eq ".") {
	  push @dirs, $dir;
      }
  }
  @dirs2 = ();

  # Remove the "subdir/.." parts.
  foreach $dir (@dirs) {
    if ( $dir !~ /^\.\.$/ ) {
        push @dirs2, $dir;
    } else {
        pop @dirs2;   # remove previous dir when current dir is ..
    }
  }
  if ($#dirs2 == 0 and $dirs2[0] eq "") { return "/"; }
  $abspath = join '/', @dirs2;
  return( $abspath );
}

#-------------------------------------------------------------------------------

sub subst_env_path {
#
# Substitute for any environment variables contained in a pathname.
# Assumes the directory separator is "/".
#
  my $path = shift;
  my $newpath;         # resulting pathname
  my $nm = "subst_env_path";

# Strip off any leading or trailing whitespace.  (This pattern won't match if
# there's embedded whitespace.
  $path =~ s!^\s*(\S*)\s*$!$1!;

  my ($dir, @dirs2);
  my @dirs = split "/", $path, -1;   # The -1 prevents split from stripping trailing nulls
                                     # This enables correct processing of the input "/".

  foreach $dir (@dirs) {
    if ( $dir =~ m/(^[^\$]*)\$(.*$)/ ) {
        my $startvar = $1;
        my $envvarnm = $2;
        if ( ! defined($ENV{$envvarnm}) ) {
           die "${nm}:: ENV variable $envvarnm is in pathname ($path) -- but NOT defined\n";
        }
        push @dirs2, "$startvar$ENV{$envvarnm}";
    } elsif ( $dir =~ m/\$/) {
        die "${nm}:: malformed ENV variable is in pathname ($path)\n";
    } else {
        push @dirs2, $dir;
    }
  }
  $newpath = join '/', @dirs2;
  return( $newpath );
}

#-------------------------------------------------------------------------------

sub mkdirp {
    my ($dir) = @_;
    my (@dirs) = split /\//, $dir;
    my (@subdirs, $path);

    # if $dir is absolute pathname then @dirs will start with ""
    if ($dirs[0] eq "") { push @subdirs, shift @dirs; }  

    while ( @dirs ) { # check that each subdir exists and mkdir if it doesn't
	push @subdirs, shift @dirs;
	$path = join '/', @subdirs;
	unless (-d $path or mkdir($path, 0777)) { return 0; }
    }
    return 1;
}

#-------------------------------------------------------------------------------

sub get_option {

    my ($mes, @expect) = @_;
    my ($ans, $expect, $max_tries);

    $max_tries = 5;
    print $mes;
    while ($max_tries) {
	$ans = <>; chomp $ans;
	--$max_tries;
	$ans =~ s/^\s+//;
	$ans =~ s/\s+$//;
	# Check for null response which indicates that default is accepted.
	unless ($ans) { return ""; }
	foreach $expect (@expect) {
	    if ($ans =~ /^$expect$/i) { return $expect; }
	}
	if ($max_tries > 1) {
	    print "$ans does not match any of the expected values: @expect\n";
	    print "Please try again: ";
	} elsif ($max_tries == 1) {
	    print "$ans does not match any of the expected values: @expect\n";
	    print "Last chance! ";
	}
    }
    die "Failed to get answer to question: $mes\n";
}

#-------------------------------------------------------------------------------

sub version {
# The version is found in CLM's ChangeLog file.
# $cfgdir is set by the configure script to the name of its directory.

    my ($cfgdir) = @_;

    my $logfile = "$cfgdir/../doc/ChangeLog";

    my $fh = IO::File->new($logfile, '<') or die "** can't open ChangeLog file: $logfile\n";

    while (my $line = <$fh>) {

	if ($line =~ /^Tag name:\s*[clm0-9_.-]*\s*[toin]*\s*([cesmclm0-9_.-]+)$/ ) {
	    print "$1\n";
	    exit;
	}
    }

}

#-------------------------------------------------------------------------------

sub is_valid_directory {
#
# Validate that the input is a valid existing directory.
# If allowEnv=>1 expand environment variables.
#
  my ($dir, %opts) = @_;
  my $nm = "is_valid_directory";

  my $valid = 0;
  # Expand environment variables
  if ( $opts{'allowEnv'} ) {
     $dir = subst_env_path( $dir );
  }
  if ( -d $dir ) { $valid = 1; }
  return( $valid );
  
}

#-------------------------------------------------------------------------------

sub print_hash {
    my %h = @_;
    my ($k, $v);
    while ( ($k,$v) = each %h ) { print "$k => $v\n"; }
}

